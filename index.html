<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆä½“ï¼ˆæ¥µé™UXç‰ˆï¼šãƒ•ã‚©ãƒ«ãƒ€è¦‹å‡ºã—/æŠ˜ã‚ŠãŸãŸã¿/ãƒ•ã‚©ãƒ«ãƒ€åˆ¥æ‰‹å‹•é †/â˜…/DnD/ãƒ•ã‚©ãƒ«ãƒ€æ–°è¦/ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ï¼‰</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#5b6474;
      --line:#e6e8f0;
      --primary:#2563eb;
      --primary2:#1d4ed8;
      --danger:#dc2626;
      --ok:#16a34a;
      --shadow: 0 10px 24px rgba(15, 23, 42, .08);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b1020;
        --panel:#0f1630;
        --text:#eaf0ff;
        --muted:#a7b1c7;
        --line:#223055;
        --primary:#6aa7ff;
        --primary2:#3f8cff;
        --danger:#ff4d6d;
        --ok:#2bd576;
        --shadow: 0 14px 30px rgba(0,0,0,.35);
      }
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{ max-width: 1180px; margin: 18px auto 42px; padding: 0 14px; }

    header{
      display:flex; align-items:flex-end; justify-content:space-between; gap:14px;
      margin-bottom: 12px;
    }
    h1{ font-size: 18px; margin:0; letter-spacing:.2px; }
    .sub{
      margin-top:6px;
      font-size: 12px; color: var(--muted);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      border-radius:999px;
      padding: 4px 10px;
      background: rgba(255,255,255,.45);
    }
    @media (prefers-color-scheme: dark){
      .chip{ background: rgba(0,0,0,.18); }
    }
    .chipSelect select{
      width: 240px;
      padding: 6px 8px;
      border-radius: 10px;
      border:1px solid var(--line);
      background: transparent;
      color: var(--text);
      font-size: 12px;
      outline:none;
    }

    .layout{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      header{ flex-direction:column; align-items:flex-start; }
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHead{
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelTitle{
      font-weight: 900; font-size: 13px;
      display:flex; align-items:center; gap:8px;
    }
    .panelBody{ padding: 12px; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row + .row{ margin-top: 10px; }
    .grow{ flex:1; min-width: 180px; }

    input[type="text"], select, textarea{
      width:100%;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.65);
      color: var(--text);
      padding: 10px 12px;
      outline:none;
      font-size: 13px;
    }
    @media (prefers-color-scheme: dark){
      input[type="text"], select, textarea{ background: rgba(0,0,0,.18); }
    }
    textarea{
      font-family: var(--mono);
      min-height: 320px;
      resize: vertical;
      line-height: 1.5;
    }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,.55);
      cursor:pointer;
      font-weight: 900;
      font-size: 13px;
      user-select:none;
      color: var(--text);
      white-space: nowrap;
    }
    @media (prefers-color-scheme: dark){
      .btn{ background: rgba(255,255,255,.06); }
    }
    .btn.primary{
      background: linear-gradient(180deg, var(--primary), var(--primary2));
      border-color: rgba(0,0,0,.0);
      color: #fff;
    }
    .btn.ok{
      background: linear-gradient(180deg, rgba(22,163,74,.95), rgba(22,163,74,.82));
      border-color: rgba(0,0,0,.0);
      color:#fff;
    }
    .btn.danger{
      background: linear-gradient(180deg, var(--danger), rgba(220,38,38,.86));
      border-color: rgba(0,0,0,.0);
      color:#fff;
    }
    @media (prefers-color-scheme: dark){
      .btn.danger{ background: linear-gradient(180deg, var(--danger), rgba(255,77,109,.78)); }
      .btn.ok{ background: linear-gradient(180deg, var(--ok), rgba(43,213,118,.78)); color:#07120b; }
    }
    .btn.small{ padding: 8px 10px; border-radius: 10px; font-size: 12px; }

    .scopeBadgeBtn{
      max-width: 200px;
      overflow:hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .hint{ font-size: 12px; color: var(--muted); line-height: 1.5; margin-top: 8px; }

    /* ========== list ========== */
    .list{
      display:flex; flex-direction:column;
      gap: 8px;
      max-height: min(560px, calc(100vh - 380px));
      overflow:auto;
      padding-right: 2px;
    }
    .sublist{
      display:flex; flex-direction:column;
      gap: 6px;
    }
    .sectionHeader{
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
      padding: 2px 2px 0;
      user-select:none;
    }
    .emptyState{
      padding: 10px 12px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    /* Folder headers (All + Manual + No search OR scoped search) */
    .folderHeader{
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.72);
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
      user-select:none;
      outline: none;
      position: sticky;
      top: 0;
      z-index: 6;
      backdrop-filter: blur(6px);
    }
    @media (prefers-color-scheme: dark){
      .folderHeader{ background: rgba(15,22,48,.78); }
    }
    .folderHeader:hover{ filter: brightness(1.02); }
    .folderHeader:focus{
      box-shadow: 0 0 0 3px rgba(37,99,235,.16);
    }
    @media (prefers-color-scheme: dark){
      .folderHeader:focus{
        box-shadow: 0 0 0 3px rgba(106,167,255,.18);
      }
    }
    .folderHeader.active{
      border-color: rgba(37,99,235,.55);
      box-shadow: 0 0 0 3px rgba(37,99,235,.10);
    }
    @media (prefers-color-scheme: dark){
      .folderHeader.active{
        border-color: rgba(106,167,255,.65);
        box-shadow: 0 0 0 3px rgba(106,167,255,.14);
      }
    }
    .fhLeft{
      display:flex; align-items:center; gap:8px; min-width:0;
    }
    .fhCaret{
      width: 18px;
      text-align:center;
      font-weight: 900;
      flex:none;
    }
    .fhName{
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
    }
    .fhRight{
      display:flex;
      align-items:center;
      gap:8px;
      color: var(--muted);
      font-size: 12px;
      flex:none;
    }
    .fhCount{
      border:1px solid var(--line);
      border-radius: 999px;
      padding: 2px 8px;
      background: rgba(255,255,255,.45);
      white-space: nowrap;
    }
    @media (prefers-color-scheme: dark){
      .fhCount{ background: rgba(0,0,0,.18); }
    }
    .fhDot{
      width: 8px; height: 8px; border-radius: 999px;
      background: rgba(37,99,235,.85);
      flex:none;
    }
    @media (prefers-color-scheme: dark){
      .fhDot{ background: rgba(106,167,255,.85); }
    }

    .sceneItem{
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.55);
      padding: 10px 10px;
      cursor:pointer;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      user-select:none;
      outline: none;
    }
    @media (prefers-color-scheme: dark){
      .sceneItem{ background: rgba(255,255,255,.06); }
    }
    .sceneItem:hover{ filter: brightness(1.02); }
    .sceneItem.active{
      border-color: rgba(37,99,235,.55);
      box-shadow: 0 0 0 3px rgba(37,99,235,.10);
    }
    @media (prefers-color-scheme: dark){
      .sceneItem.active{
        border-color: rgba(106,167,255,.65);
        box-shadow: 0 0 0 3px rgba(106,167,255,.16);
      }
    }

    .sceneLeft{ min-width: 0; }
    .sceneName{
      font-weight: 900;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 260px;
    }
    .sceneMeta{ font-size: 11px; color: var(--muted); margin-top: 4px; }

    .sceneRight{
      display:flex;
      gap:8px;
      align-items:center;
      flex:none;
      padding-top: 2px;
    }

    .iconBtn{
      width: 34px;
      height: 30px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border:1px solid var(--line);
      border-radius: 10px;
      background: rgba(255,255,255,.55);
      color: var(--text);
      cursor:pointer;
      font-weight: 900;
      line-height: 1;
      user-select:none;
      flex:none;
    }
    @media (prefers-color-scheme: dark){
      .iconBtn{ background: rgba(255,255,255,.06); }
    }
    .iconBtn:hover{ filter: brightness(1.02); }

    .starBtn.active{
      border-color: rgba(234,179,8,.35);
      box-shadow: 0 0 0 3px rgba(234,179,8,.10);
    }
    @media (prefers-color-scheme: dark){
      .starBtn.active{
        border-color: rgba(250,204,21,.45);
        box-shadow: 0 0 0 3px rgba(250,204,21,.14);
      }
    }

    .scopeBtn.active{
      border-color: rgba(37,99,235,.55);
      box-shadow: 0 0 0 3px rgba(37,99,235,.10);
    }
    @media (prefers-color-scheme: dark){
      .scopeBtn.active{
        border-color: rgba(106,167,255,.65);
        box-shadow: 0 0 0 3px rgba(106,167,255,.14);
      }
    }

    .dragHandle{ cursor: grab; }
    .dragHandle:active{ cursor: grabbing; }
    .dragHandle.disabled{
      opacity: .45;
      cursor: not-allowed;
    }

    .dot{
      width:10px; height:10px; border-radius:999px;
      border:1px solid var(--line);
      background: transparent;
      flex:none;
    }
    .dot.draft{ background: rgba(234,179,8,.95); border-color: rgba(234,179,8,.25); }
    @media (prefers-color-scheme: dark){
      .dot.draft{ background: rgba(250,204,21,.95); }
    }

    /* Drop indicators (scene) */
    .sceneItem.drop-before{ box-shadow: 0 -3px 0 0 rgba(37,99,235,.85) inset; }
    .sceneItem.drop-after{  box-shadow: 0  3px 0 0 rgba(37,99,235,.85) inset; }
    @media (prefers-color-scheme: dark){
      .sceneItem.drop-before{ box-shadow: 0 -3px 0 0 rgba(106,167,255,.85) inset; }
      .sceneItem.drop-after{  box-shadow: 0  3px 0 0 rgba(106,167,255,.85) inset; }
    }
    .sceneItem.dragging{ opacity: .65; }

    details{
      margin-top: 12px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    summary{
      cursor:pointer;
      list-style:none;
      padding: 10px 12px;
      font-weight: 900;
      font-size: 13px;
      display:flex; align-items:center; justify-content:space-between;
    }
    summary::-webkit-details-marker{ display:none; }
    .detailsBody{ padding: 12px; border-top:1px solid var(--line); }

    .dangerZone{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(220,38,38,.35);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    .statusLine{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      font-size: 12px; color: var(--muted);
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.45);
      color: var(--muted);
      white-space: nowrap;
    }
    @media (prefers-color-scheme: dark){
      .badge{ background: rgba(0,0,0,.18); }
    }
    .badge.warn{ color: #7c5a00; border-color: rgba(234,179,8,.35); }
    @media (prefers-color-scheme: dark){
      .badge.warn{ color: #ffe08a; }
    }
    .badge input[type="checkbox"]{ width: 14px; height: 14px; }

    .badgeSelect select{
      width: 160px;
      padding: 4px 8px;
      border-radius: 10px;
      border:1px solid var(--line);
      background: transparent;
      color: var(--text);
      font-size: 12px;
      outline:none;
    }

    .toast{
      position: fixed; right: 16px; bottom: 16px;
      background: rgba(15, 23, 42, .92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      opacity: 0;
      transform: translateY(8px);
      transition: .18s ease;
      pointer-events:none;
      z-index: 2000;
    }
    .toast.show{ opacity: 1; transform: translateY(0); }

    /* ========= drawer ========= */
    #backdrop{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.35);
      opacity: 0;
      pointer-events: none;
      transition: .18s ease;
      z-index: 1400;
    }

    body.lib-collapsed .layout{ grid-template-columns: 1fr; }
    body.lib-collapsed #libraryPanel{
      position: fixed;
      top: 0; left: 0; bottom: 0;
      width: 360px;
      max-width: 92vw;
      z-index: 1500;
      transform: translateX(-105%);
      transition: transform .18s ease;
      border-radius: 0;
      height: 100vh;
    }
    body.lib-collapsed.lib-open #libraryPanel{ transform: translateX(0); }
    body.lib-collapsed.lib-open #backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.lib-collapsed #libraryPanel .list{
      max-height: calc(100vh - 410px);
    }

    /* compact */
    body.compact .sceneItem{ padding: 8px 10px; }
    body.compact .sceneName{ font-size: 12px; max-width: 220px; }
    body.compact .sceneMeta{ display:none; }
    body.compact .sceneRight{ padding-top: 0; }
    body.compact .folderHeader{ padding: 7px 10px; }
    body.compact .fhName{ max-width: 210px; }

    #libraryDock, #libraryClose{ display:none; }
    body.lib-collapsed #libraryClose{ display:inline-flex; }
    body.lib-collapsed:not(.is-mobile) #libraryDock{ display:inline-flex; }

    /* ========= folder dialog ========= */
    dialog{
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 0;
      width: min(760px, 94vw);
      box-shadow: var(--shadow);
      background: var(--panel);
      color: var(--text);
    }
    dialog::backdrop{ background: rgba(0,0,0,.35); }
    .modalHead{
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .modalTitle{ font-weight: 900; font-size: 13px; }
    .modalBody{ padding: 12px; }
    .folderList{
      display:flex; flex-direction:column; gap:8px;
      margin-top: 10px;
      max-height: min(520px, 70vh);
      overflow:auto;
      padding-right: 2px;
    }
    .folderRow{
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.55);
      padding: 10px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      user-select:none;
    }
    @media (prefers-color-scheme: dark){
      .folderRow{ background: rgba(255,255,255,.06); }
    }
    .folderRow.drop-before{ box-shadow: 0 -3px 0 0 rgba(37,99,235,.85) inset; }
    .folderRow.drop-after{  box-shadow: 0  3px 0 0 rgba(37,99,235,.85) inset; }
    @media (prefers-color-scheme: dark){
      .folderRow.drop-before{ box-shadow: 0 -3px 0 0 rgba(106,167,255,.85) inset; }
      .folderRow.drop-after{  box-shadow: 0  3px 0 0 rgba(106,167,255,.85) inset; }
    }

    .folderLeft{ min-width:0; }
    .folderName{
      font-weight: 900;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 420px;
    }
    .folderMeta{ font-size: 11px; color: var(--muted); margin-top: 4px; }
    .folderRight{ display:flex; gap:8px; align-items:center; flex:none; }
    .folderHandle.disabled{ opacity:.45; cursor:not-allowed; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆä½“</h1>
        <div class="sub">
          <span class="chip">Ctrl+Enterï¼šåˆä½“ã—ã¦ã‚³ãƒ”ãƒ¼</span>
          <span class="chip">Ctrl+Sï¼šä¿å­˜/æ›´æ–°ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã§ã‚·ãƒ¼ãƒ³/å›ºå®šï¼‰</span>
          <span class="chip">Ctrl+Shift+Sï¼šåå‰ä»˜ãä¿å­˜/è¤‡è£½</span>
          <span class="chip">Ctrl+Kï¼šæ¤œç´¢</span>

          <span class="chip chipSelect">
            å›ºå®šãƒ—ãƒªã‚»ãƒƒãƒˆï¼š
            <select id="fixedSelect"></select>
          </span>

          <button class="btn small" id="openFixed">å›ºå®šã‚’ç·¨é›†</button>
        </div>
      </div>

      <div class="row">
        <button class="btn" id="libraryToggle">ä¸€è¦§ã‚’éš ã™</button>
        <button class="btn primary" id="mergeCopy">åˆä½“ã—ã¦ã‚³ãƒ”ãƒ¼</button>
        <button class="btn" id="copyOnly">å‡ºåŠ›ã ã‘ã‚³ãƒ”ãƒ¼</button>
      </div>
    </header>

    <div class="layout">
      <!-- Left: Scene Library -->
      <section class="panel" id="libraryPanel" aria-label="ã‚·ãƒ¼ãƒ³ä¸€è¦§">
        <div class="panelHead">
          <div class="panelTitle">ã‚·ãƒ¼ãƒ³ä¸€è¦§</div>
          <div class="statusLine">
            <label class="badge" title="ä¸€è¦§ã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ã—ã¦è¡¨ç¤ºè¡Œæ•°ã‚’å¢—ã‚„ã—ã¾ã™">
              <input type="checkbox" id="compactToggle" />
              ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆ
            </label>

            <label class="badge" title="ãŠæ°—ã«å…¥ã‚Šï¼ˆâ˜…ï¼‰ã‚’ä¸Šã«ã¾ã¨ã‚ã¦è¡¨ç¤ºã—ã¾ã™">
              <input type="checkbox" id="favPinToggle" />
              â˜…ä¸Š
            </label>

            <label class="badge" title="ãŠæ°—ã«å…¥ã‚Šï¼ˆâ˜…ï¼‰ã ã‘è¡¨ç¤ºã—ã¾ã™">
              <input type="checkbox" id="favOnlyToggle" />
              â˜…ã®ã¿
            </label>

            <span class="badge badgeSelect" title="æ‰‹å‹•ã®ã¨ãã ã‘ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã³æ›¿ãˆã§ãã¾ã™ï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã¿ï¼‰">
              ä¸¦ã³é †ï¼š
              <select id="sortSelect">
                <option value="manual">æ‰‹å‹•ï¼ˆãƒ‰ãƒ©ãƒƒã‚°å¯ï¼‰</option>
                <option value="updated">æ›´æ–°æ—¥æ™‚</option>
                <option value="name">åå‰</option>
              </select>
            </span>

            <span class="badge" id="sceneCount">0ä»¶</span>

            <button class="btn small" id="libraryDock" title="å·¦ã«å›ºå®šã—ã¦å¸¸æ™‚è¡¨ç¤ºã«æˆ»ã™">å›ºå®šè¡¨ç¤º</button>
            <button class="btn small" id="libraryClose" title="ä¸€è¦§ã‚’é–‰ã˜ã‚‹ï¼ˆEscã§ã‚‚å¯ï¼‰">é–‰ã˜ã‚‹</button>
          </div>
        </div>

        <div class="panelBody">
          <div class="row">
            <select id="folderFilter" class="grow" title="ãƒ•ã‚©ãƒ«ãƒ€ã§çµã‚Šè¾¼ã¿"></select>
            <button class="btn small" id="folderCollapseAll" title="è¡¨ç¤ºä¸­ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã™ã¹ã¦æŠ˜ã‚ŠãŸãŸã‚€ï¼ˆæ¡ä»¶ï¼šã™ã¹ã¦ï¼‹æ‰‹å‹•ï¼‹æ¤œç´¢ãªã—ï¼‰" style="display:none;">å…¨æŠ˜</button>
            <button class="btn small" id="folderExpandAll" title="è¡¨ç¤ºä¸­ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã™ã¹ã¦å±•é–‹ï¼ˆæ¡ä»¶ï¼šã™ã¹ã¦ï¼‹æ‰‹å‹•ï¼‹æ¤œç´¢ãªã—ï¼‰" style="display:none;">å…¨å±•</button>
            <button class="btn small" id="folderManage">ãƒ•ã‚©ãƒ«ãƒ€ç®¡ç†</button>
          </div>

          <div class="row">
            <input id="search" type="text" class="grow" placeholder="æ¤œç´¢ï¼ˆåå‰ï¼‰" />
            <button class="btn small" id="clearSearch" title="æ¤œç´¢ã‚’ã‚¯ãƒªã‚¢">Ã—</button>
            <button class="btn small scopeBadgeBtn" id="searchScopeBadge" style="display:none;" title="ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ã‚’è§£é™¤"></button>
            <button class="btn small" id="newScene">æ–°è¦</button>
          </div>

          <div class="hint" id="libraryHint" style="margin-top:6px;">
            ğŸ“ã§çµã‚Šè¾¼ã¿ã€‚â˜…ã§ãŠæ°—ã«å…¥ã‚Šã€‚â‰¡ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã³æ›¿ãˆï¼ˆæ‰‹å‹•ï¼†æ¤œç´¢ãªã—ï¼†åŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ï¼‰ã€‚
          </div>

          <div class="list" id="sceneList" style="margin-top:10px;"></div>

          <div class="dangerZone">
            <button class="btn danger" id="deleteScene" disabled>é¸æŠä¸­ã‚’å‰Šé™¤</button>
            <span class="hint" style="margin:0;">â€» å‰Šé™¤ã¯ç¢ºèªãŒå‡ºã¾ã™</span>
          </div>
        </div>
      </section>

      <!-- Right: Scene Editor -->
      <section class="panel" aria-label="ç·¨é›†">
        <div class="panelHead">
          <div class="panelTitle">ç·¨é›†</div>
          <div class="statusLine">
            <button class="iconBtn starBtn" id="sceneFavBtn" type="button" title="ãŠæ°—ã«å…¥ã‚Š" aria-label="ãŠæ°—ã«å…¥ã‚Š" disabled>â˜†</button>

            <span class="badge badgeSelect" title="ã“ã®ã‚·ãƒ¼ãƒ³ã®ãƒ•ã‚©ãƒ«ãƒ€ï¼ˆæ–°è¦ã®ä¿å­˜å…ˆã«ã‚‚ãªã‚Šã¾ã™ï¼‰">
              ğŸ“
              <select id="sceneFolderSelect"></select>
            </span>

            <span class="badge" id="currentSceneName">æ–°è¦</span>
            <span class="badge warn" id="sceneDirtyBadge" style="display:none;">æœªä¿å­˜ï¼ˆä¸‹æ›¸ãï¼‰</span>
          </div>
        </div>

        <div class="panelBody">
          <div class="row">
            <button class="btn ok" id="sceneSave">ä¿å­˜</button>
            <button class="btn" id="sceneSaveAs">åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜</button>
            <button class="btn" id="sceneRevert" style="display:none;">ä¿å­˜æ¸ˆã¿ã«æˆ»ã™</button>
            <button class="btn" id="sceneClear">ã‚·ãƒ¼ãƒ³å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢</button>
          </div>

          <textarea id="scene" placeholder="ã‚·ãƒ¼ãƒ³ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆç·¨é›†å¯¾è±¡ï¼‰"></textarea>

          <div class="row" style="margin-top:10px;">
            <button class="btn primary" id="mergeCopy2" style="flex:1;">åˆä½“ã—ã¦ã‚³ãƒ”ãƒ¼</button>
            <button class="btn" id="showOutput">åˆä½“çµæœã‚’é–‹ã</button>
          </div>

          <div class="hint">
            æ—¢å­˜ã‚’ç·¨é›†ã—ãŸã‚‰ã€Œæ›´æ–°ã€ã€‚æ—¢å­˜ã‚’åˆ¥åã§æ®‹ã™ãªã‚‰ã€Œè¤‡è£½ã—ã¦ä¿å­˜ã€ã€‚
          </div>
        </div>
      </section>
    </div>

    <!-- Output -->
    <details id="outputDetails">
      <summary>åˆä½“çµæœï¼ˆç¢ºèªãƒ»æ‰‹å‹•ã‚³ãƒ”ãƒ¼ç”¨ï¼‰</summary>
      <div class="detailsBody">
        <div class="row">
          <button class="btn" id="refreshOutput">åˆä½“çµæœã‚’æ›´æ–°</button>
          <button class="btn" id="copyOutput">ã“ã®æ¬„ã‚’ã‚³ãƒ”ãƒ¼</button>
        </div>
        <textarea id="output" style="min-height:220px; margin-top:10px;" placeholder="åˆä½“çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™"></textarea>
        <div class="hint">â€» è‡ªå‹•ã‚³ãƒ”ãƒ¼ãŒå¤±æ•—ã™ã‚‹å ´åˆã¯ã€ã“ã®æ¬„ã‚’é–‹ã„ã¦ Ctrl+C ã§ã‚³ãƒ”ãƒ¼ã§ãã¾ã™ã€‚</div>
      </div>
    </details>

    <!-- Fixed -->
    <details id="fixedDetails">
      <summary>å›ºå®šãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼ˆãƒ—ãƒªã‚»ãƒƒãƒˆå¯¾å¿œ / æ™®æ®µã¯é–‰ã˜ã¦OKï¼‰</summary>
      <div class="detailsBody">
        <div class="row">
          <div class="statusLine">
            <span class="badge" id="fixedCurrentName">â€”</span>
            <span class="badge warn" id="fixedDirtyBadge" style="display:none;">æœªä¿å­˜ï¼ˆä¸‹æ›¸ãï¼‰</span>
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <button class="btn ok" id="fixedSave">ä¿å­˜</button>
          <button class="btn" id="fixedSaveAs">è¤‡è£½ã—ã¦ä¿å­˜</button>
          <button class="btn" id="fixedRevert" style="display:none;">ä¿å­˜æ¸ˆã¿ã«æˆ»ã™</button>
          <button class="btn" id="fixedClear">å›ºå®šå…¥åŠ›ã‚’ã‚¯ãƒªã‚¢</button>
        </div>

        <textarea id="fixed" style="min-height:220px; margin-top:10px;" placeholder="å›ºå®šãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"></textarea>

        <div class="dangerZone">
          <button class="btn danger" id="fixedDelete">ã“ã®å›ºå®šãƒ—ãƒªã‚»ãƒƒãƒˆã‚’å‰Šé™¤</button>
          <span class="hint" style="margin:0;">â€» æœ€å¾Œã®1ä»¶ã¯å‰Šé™¤ã§ãã¾ã›ã‚“</span>
        </div>

        <div class="hint">å›ºå®šã‚‚ï¼šç·¨é›†ã—ãŸã‚‰ã€Œæ›´æ–°ã€ã€åˆ¥åã§æ®‹ã™ãªã‚‰ã€Œè¤‡è£½ã—ã¦ä¿å­˜ã€ã€‚</div>
      </div>
    </details>

    <!-- Options -->
    <details id="optionsDetails">
      <summary>è©³ç´°è¨­å®šï¼ˆå¿…è¦ãªã¨ãã ã‘ï¼‰</summary>
      <div class="detailsBody">
        <div class="row">
          <label style="min-width:88px; margin:0; color:var(--muted); font-size:12px;">åŒºåˆ‡ã‚Š</label>
          <select id="dividerPreset" class="grow">
            <option value="\n\n" selected>ç©ºè¡Œï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰</option>
            <option value="\n\n---\n\n">---</option>
            <option value="\n\n================\n\n">====</option>
            <option value="CUSTOM">ã‚«ã‚¹ã‚¿ãƒ </option>
          </select>
          <input id="dividerCustom" type="text" class="grow" placeholder="ã‚«ã‚¹ã‚¿ãƒ åŒºåˆ‡ã‚Šï¼ˆä¾‹ï¼š\n\n[SCENE]\n\nï¼‰" style="display:none;" />
        </div>

        <div class="row">
          <label class="row" style="gap:8px; color:var(--muted); font-size:12px;">
            <input type="checkbox" id="trim" checked />
            ç©ºç™½ã‚’æ•´ç†ã—ã¦åˆä½“ã™ã‚‹ï¼ˆå…ˆé ­ã¯ä¿æŒãƒ»è¡Œæœ«ã®ã‚¹ãƒšãƒ¼ã‚¹/ã‚¿ãƒ–ã®ã¿ï¼‰
          </label>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="exportJson">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆã‚·ãƒ¼ãƒ³ï¼‹å›ºå®šï¼‹ãƒ•ã‚©ãƒ«ãƒ€ / JSONï¼‰</button>
          <label class="btn" for="importJson" style="cursor:pointer;">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</label>
          <input id="importJson" type="file" accept="application/json" style="display:none;" />
          <span class="hint" style="margin:0;">â€» PCç§»è¡Œãƒ»ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç”¨</span>
        </div>
      </div>
    </details>

  </div>

  <div id="backdrop" aria-hidden="true"></div>
  <div id="toast" class="toast">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ</div>

  <!-- Folder Manage Dialog -->
  <dialog id="folderDialog">
    <div class="modalHead">
      <div class="modalTitle">ãƒ•ã‚©ãƒ«ãƒ€ç®¡ç†ï¼ˆâ‰¡ã§ä¸¦ã³æ›¿ãˆï¼‰</div>
      <div class="row" style="gap:8px;">
        <button class="btn small" id="folderNew" type="button">æ–°è¦</button>
        <button class="btn small" id="folderDialogClose" type="button">é–‰ã˜ã‚‹</button>
      </div>
    </div>
    <div class="modalBody">
      <div class="hint">
        ãƒ»â‰¡ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ•ã‚©ãƒ«ãƒ€é †ã‚’å¤‰æ›´ã§ãã¾ã™ï¼ˆ<strong>æœªåˆ†é¡ã¯å›ºå®š</strong>ï¼‰ã€‚<br>
        ãƒ»å‰Šé™¤ã—ãŸãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã‚·ãƒ¼ãƒ³ã¯<strong>æœªåˆ†é¡</strong>ã¸ç§»å‹•ã—ã¾ã™ï¼ˆå®‰å…¨è¨­è¨ˆï¼‰ã€‚
      </div>
      <div id="folderList" class="folderList"></div>
    </div>
  </dialog>

  <script>
    const $ = (id) => document.getElementById(id);

    // ---- DOM ----
    const libraryToggle = $("libraryToggle");
    const backdrop = $("backdrop");
    const libraryClose = $("libraryClose");
    const libraryDock = $("libraryDock");
    const compactToggle = $("compactToggle");
    const favPinToggle = $("favPinToggle");
    const favOnlyToggle = $("favOnlyToggle");
    const sortSelect = $("sortSelect");
    const libraryHint = $("libraryHint");

    const folderFilter = $("folderFilter");
    const folderManage = $("folderManage");
    const folderCollapseAllBtn = $("folderCollapseAll");
    const folderExpandAllBtn = $("folderExpandAll");
    const folderDialog = $("folderDialog");
    const folderListEl = $("folderList");
    const folderNewBtn = $("folderNew");
    const folderDialogCloseBtn = $("folderDialogClose");

    const search = $("search");
    const clearSearchBtn = $("clearSearch");
    const searchScopeBadge = $("searchScopeBadge");
    const sceneList = $("sceneList");
    const sceneCount = $("sceneCount");
    const deleteSceneBtn = $("deleteScene");

    const currentSceneNameBadge = $("currentSceneName");
    const sceneDirtyBadge = $("sceneDirtyBadge");
    const sceneFavBtn = $("sceneFavBtn");
    const sceneFolderSelect = $("sceneFolderSelect");

    const scene = $("scene");
    const fixed = $("fixed");
    const output = $("output");

    const fixedSelect = $("fixedSelect");
    const fixedCurrentNameBadge = $("fixedCurrentName");
    const fixedDirtyBadge = $("fixedDirtyBadge");
    const fixedDeleteBtn = $("fixedDelete");

    const fixedDetails = $("fixedDetails");
    const outputDetails = $("outputDetails");

    const dividerPreset = $("dividerPreset");
    const dividerCustom = $("dividerCustom");
    const trim = $("trim");

    const toast = $("toast");

    // ---- UI persistence keys ----
    const LS_UI_COLLAPSED = "ui_lib_collapsed_v1";
    const LS_UI_COMPACT  = "ui_lib_compact_v1";
    const LS_UI_FAV_PIN  = "ui_fav_pin_v1";
    const LS_UI_FAV_ONLY = "ui_fav_only_v1";
    const LS_UI_SORT     = "ui_scene_sort_v1";
    const LS_UI_FOLDER_FILTER = "ui_folder_filter_v1";
    const LS_UI_NEW_SCENE_FOLDER = "ui_new_scene_folder_v1";
    const LS_UI_FOLDER_COLLAPSE = "ui_folder_collapse_state_v1";
    const LS_UI_SEARCH_SCOPE = "ui_search_scope_folder_v1";

    // ---- DB keys ----
    const LS_SCENE_DB = "pm_scene_db_v2";
    const LS_SCENE_DB_OLD = "pm_scene_db_v1";
    const LS_SCENE_SELECTED_ID = "pm_scene_selected_id_v1";
    const LS_SCENE_DRAFT_NEW = "pm_scene_draft_new_v1";
    const LS_SCENE_DRAFT_PREFIX = "pm_scene_draft_v1_";
    const LS_SCENE_MIGRATED = "pm_scene_db_v1_migrated";

    const LS_FOLDER_DB = "pm_folder_db_v2";
    const LS_FOLDER_DB_OLD = "pm_folder_db_v1";
    const FOLDER_UNFILED_ID = "unfiled";

    // ---- old libs for migration (very old) ----
    const OLD_SCENE_LIB_KEYS = ["pm_scene_library_v3", "pm_scene_library_v2", "pm_scene_library_v1"];
    const OLD_SELECTED_NAME_KEYS = ["pm_selected_scene_name_v3", "pm_selected_scene_name_v2", "pm_selected_scene_name_v1"];

    // ---- Fixed presets keys ----
    const LS_FIXED_LIB = "pm_fixed_library_v1";
    const LS_FIXED_SELECTED = "pm_selected_fixed_name_v1";
    const LS_FIXED_DRAFT_PREFIX = "pm_draft_fixed_v1_";
    const LS_OLD_FIXED_SINGLE = "pm_fixed_v3";

    // ---- State ----
    let currentSceneId = null;
    let boundSceneId = null;
    let switchingScene = false;
    let switchingFromSceneId = null;

    let currentFixedName = "";
    let boundFixedName = "";
    let switchingFixed = false;
    let switchingFromFixedName = "";

    let lastMerged = "";

    // UI state
    let collapsedPref = (localStorage.getItem(LS_UI_COLLAPSED) ?? "0") === "1";
    let compactPref   = (localStorage.getItem(LS_UI_COMPACT)  ?? "0") === "1";
    let favPinPref    = (localStorage.getItem(LS_UI_FAV_PIN)  ?? "1") === "1";
    let favOnlyPref   = (localStorage.getItem(LS_UI_FAV_ONLY) ?? "0") === "1";
    let sortMode      = (localStorage.getItem(LS_UI_SORT)     ?? "manual");
    let folderFilterId = (localStorage.getItem(LS_UI_FOLDER_FILTER) ?? "ALL");
    let newSceneFolderId = (localStorage.getItem(LS_UI_NEW_SCENE_FOLDER) ?? FOLDER_UNFILED_ID);

    // folder collapse state
    let folderCollapseMap = {};

    // search scope (folder-only search)
    let searchScopeFolderId = (localStorage.getItem(LS_UI_SEARCH_SCOPE) ?? "");

    // DnD state (scene)
    let dragState = null; // {id, group, folderId}
    let dropEl = null;
    let dropPos = "before";
    let suppressClickUntil = 0;

    // DnD state (folder)
    let folderDragId = null;
    let folderDropEl = null;
    let folderDropPos = "before";

    // render assist
    let scrollToActiveNext = false;

    // new-scene toast override
    let nextNewSceneToast = "";

    // ---- Utils ----
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 1200);
    }
    function nowISO(){ return new Date().toISOString(); }
    function uuid(){
      if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
      return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }
    function toLF(s){ return (s ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"); }

    // ç©ºç™½æ•´ç†ONã§ã‚‚ã€Œå…ˆé ­ã€ã‚„ã€Œè¡Œãã®ã‚‚ã®ã€ã‚’æ¶ˆã•ãªã„å®‰å…¨ç‰ˆ
    function normalizeForMerge(s){
      const t = toLF(s);
      if (!trim.checked) return t;
      return t.split("\n").map(line => line.replace(/[ \t]+$/g, "")).join("\n");
    }

    function getDivider(){
      const v = dividerPreset.value;
      if (v === "CUSTOM") return dividerCustom.value.replaceAll("\\n", "\n");
      return v.replaceAll("\\n", "\n");
    }

    function merge(){
      const a = normalizeForMerge(fixed.value);
      const b = normalizeForMerge(scene.value);
      const d = getDivider();
      if (!a && !b) return "";
      if (!a) return b;
      if (!b) return a;
      return a + d + b;
    }

    async function copyToClipboard(text){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try{
          output.value = text;
          outputDetails.open = true;
          output.focus();
          output.select();
          return document.execCommand("copy");
        } catch {
          return false;
        }
      }
    }

    function formatUpdated(iso){
      if (!iso) return "";
      const d = new Date(iso);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const day = String(d.getDate()).padStart(2,"0");
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      return `${y}-${m}-${day} ${hh}:${mm}`;
    }

    // é€£ç•ªå‘½åï¼ˆã‚µãƒ³ãƒ—ãƒ« / ã‚µãƒ³ãƒ—ãƒ«ï¼ˆ2ï¼‰ / ã‚µãƒ³ãƒ—ãƒ«ï¼ˆ3ï¼‰â€¦ï¼‰
    function uniqueName(existingSet, desired, fallback="scene"){
      let name = (desired ?? "").trim();
      if (!name) name = fallback;

      if (!existingSet.has(name)) return name;

      let base = name;
      let start = 2;

      const m = name.match(/^(.*?)[ï¼ˆ(](\d+)[ï¼‰)]$/);
      if (m){
        base = (m[1] ?? "").trim() || name;
        const n = parseInt(m[2], 10);
        start = Number.isFinite(n) ? Math.max(2, n + 1) : 2;
      }

      for (let i = start; i < 10000; i++){
        const cand = `${base}ï¼ˆ${i}ï¼‰`;
        if (!existingSet.has(cand)) return cand;
      }
      return `${base}ï¼ˆ${Date.now()}ï¼‰`;
    }

    function asNum(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    // =========================
    // Folder collapse state
    // =========================
    function loadFolderCollapseMap(){
      try{
        const raw = localStorage.getItem(LS_UI_FOLDER_COLLAPSE);
        const obj = raw ? JSON.parse(raw) : {};
        if (!obj || typeof obj !== "object") return {};
        return obj;
      } catch {
        return {};
      }
    }
    function saveFolderCollapseMap(){
      localStorage.setItem(LS_UI_FOLDER_COLLAPSE, JSON.stringify(folderCollapseMap));
    }
    function sanitizeFolderCollapseMap(){
      const set = folderSet();
      let changed = false;
      for (const k of Object.keys(folderCollapseMap)){
        if (!set.has(k)){
          delete folderCollapseMap[k];
          changed = true;
        }
      }
      if (changed) saveFolderCollapseMap();
    }
    function isFolderCollapsed(fid){
      return !!folderCollapseMap[fid];
    }
    function setFolderCollapsed(fid, collapsed){
      if (collapsed) folderCollapseMap[fid] = true;
      else delete folderCollapseMap[fid];
      saveFolderCollapseMap();
    }
    function toggleFolderCollapsed(fid){
      setFolderCollapsed(fid, !isFolderCollapsed(fid));
    }
    function setAllFoldersCollapsed(collapsed){
      const set = folderSet();
      for (const fid of set){
        if (collapsed) folderCollapseMap[fid] = true;
        else delete folderCollapseMap[fid];
      }
      // é¸æŠä¸­ã®ãƒ•ã‚©ãƒ«ãƒ€ã¯è¦‹ãˆã‚‹ã‚ˆã†ã«ï¼ˆè¿·å­é˜²æ­¢ï¼‰
      const db = readSceneDB();
      const s = currentSceneId ? findSceneById(db, currentSceneId) : null;
      const selFid = s ? safeFolderId(s.folderId, set) : null;
      if (selFid) delete folderCollapseMap[selFid];

      saveFolderCollapseMap();
    }
    function expandFolderForSceneId(sceneId){
      if (!sceneId) return;
      const db = readSceneDB();
      const set = folderSet();
      const s = findSceneById(db, sceneId);
      if (!s) return;
      const fid = safeFolderId(s.folderId, set);
      if (folderCollapseMap[fid]){
        delete folderCollapseMap[fid];
        saveFolderCollapseMap();
      }
    }

    // =========================
    // Folder-only search scope
    // =========================
    function sanitizeSearchScope(){
      const set = folderSet();
      if (searchScopeFolderId && !set.has(searchScopeFolderId)){
        searchScopeFolderId = "";
        localStorage.removeItem(LS_UI_SEARCH_SCOPE);
      }
    }
    function hasSearchScope(){
      const set = folderSet();
      return !!(searchScopeFolderId && set.has(searchScopeFolderId));
    }
    function setSearchScope(fidOrEmpty){
      const set = folderSet();
      const fid = (fidOrEmpty ?? "").toString();

      if (!fid){
        searchScopeFolderId = "";
        localStorage.removeItem(LS_UI_SEARCH_SCOPE);
      } else if (set.has(fid)){
        searchScopeFolderId = fid;
        localStorage.setItem(LS_UI_SEARCH_SCOPE, fid);
      } else {
        searchScopeFolderId = "";
        localStorage.removeItem(LS_UI_SEARCH_SCOPE);
      }
    }
    function updateSearchScopeBadge(folderMap){
      // ãƒ•ã‚©ãƒ«ãƒ€çµã‚Šè¾¼ã¿ä¸­ã¯â€œé™å®šâ€ãŒæ—¢ã«æˆç«‹ã—ã¦ã„ã‚‹ã®ã§ã€æ··ä¹±é˜²æ­¢ã§éš ã™
      if (folderFilterId !== "ALL"){
        searchScopeBadge.style.display = "none";
        searchScopeBadge.textContent = "";
        return;
      }

      const set = folderSet();
      if (!searchScopeFolderId || !set.has(searchScopeFolderId)){
        searchScopeBadge.style.display = "none";
        searchScopeBadge.textContent = "";
        return;
      }

      const name = (folderMap?.[searchScopeFolderId]) ?? (folderNameMap()[searchScopeFolderId] ?? "æœªåˆ†é¡");
      searchScopeBadge.style.display = "inline-flex";
      searchScopeBadge.textContent = `ğŸ“ ${name} é™å®š`;
      searchScopeBadge.title = `ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ã‚’è§£é™¤ï¼ˆç¾åœ¨ï¼š${name}ï¼‰`;
    }
    function toggleSearchScope(fid){
      const set = folderSet();
      if (!set.has(fid)) return;

      if (searchScopeFolderId === fid){
        setSearchScope("");
        scheduleRenderSceneList();
        search.focus();
        search.select();
        showToast("æ¤œç´¢ã®é™å®šã‚’è§£é™¤");
        return;
      }

      setSearchScope(fid);

      // é™å®šONï¼â€œæ¢ã™â€ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹ã®ã§ã€å³å…¥åŠ›ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
      search.focus();
      search.select();

      // è¦‹ãˆãªã„äº‹æ•…ã‚’é˜²ãï¼šå¯¾è±¡ãƒ•ã‚©ãƒ«ãƒ€ã¯å±•é–‹
      if (folderCollapseMap[fid]){
        delete folderCollapseMap[fid];
        saveFolderCollapseMap();
      }

      const name = folderNameMap()[fid] ?? "æœªåˆ†é¡";
      scheduleRenderSceneList();
      showToast(`æ¤œç´¢ã‚’ã€Œ${name}ã€ã«é™å®š`);
    }

    // =========================
    // Folder DB (v2: order)
    // =========================
    function emptyFolderDB(){ return { version: 2, folders: [] }; }

    function readFolderDB(){
      try{
        const raw = localStorage.getItem(LS_FOLDER_DB);
        if (raw){
          const obj = JSON.parse(raw);
          const folders = Array.isArray(obj?.folders) ? obj.folders : [];
          return {
            version: 2,
            folders: folders
              .filter(f => f && typeof f === "object")
              .map(f => ({
                id: String(f.id ?? ""),
                name: String(f.name ?? ""),
                createdAt: String(f.createdAt ?? nowISO()),
                updatedAt: String(f.updatedAt ?? nowISO()),
                order: asNum(f.order)
              }))
              .filter(f => f.id && f.name)
          };
        }
      } catch {}

      try{
        const raw = localStorage.getItem(LS_FOLDER_DB_OLD);
        if (!raw) return emptyFolderDB();
        const obj = JSON.parse(raw);
        const folders = Array.isArray(obj?.folders) ? obj.folders : [];
        return {
          version: 2,
          folders: folders
            .filter(f => f && typeof f === "object")
            .map((f, idx) => ({
              id: String(f.id ?? ""),
              name: String(f.name ?? ""),
              createdAt: String(f.createdAt ?? nowISO()),
              updatedAt: String(f.updatedAt ?? nowISO()),
              order: (idx+1) * 10
            }))
            .filter(f => f.id && f.name)
        };
      } catch {
        return emptyFolderDB();
      }
    }

    function writeFolderDB(db){
      localStorage.setItem(LS_FOLDER_DB, JSON.stringify({ version: 2, folders: db.folders }));
    }

    function ensureDefaultFolders(){
      const db = readFolderDB();
      const hasUnfiled = db.folders.some(f => f.id === FOLDER_UNFILED_ID);
      if (!hasUnfiled){
        db.folders.unshift({
          id: FOLDER_UNFILED_ID,
          name: "æœªåˆ†é¡",
          createdAt: nowISO(),
          updatedAt: nowISO(),
          order: 0
        });
      }
      writeFolderDB(db);
    }

    function sortedFolders(){
      const db = readFolderDB();
      const unfiled = db.folders.find(f => f.id === FOLDER_UNFILED_ID) ?? {
        id: FOLDER_UNFILED_ID, name:"æœªåˆ†é¡", createdAt: nowISO(), updatedAt: nowISO(), order: 0
      };
      const rest = db.folders.filter(f => f.id !== FOLDER_UNFILED_ID);
      rest.sort((a,b)=>{
        const ao = Number.isFinite(a.order) ? a.order : 1e18;
        const bo = Number.isFinite(b.order) ? b.order : 1e18;
        if (ao !== bo) return ao - bo;
        return a.name.localeCompare(b.name, "ja");
      });
      return [unfiled, ...rest];
    }

    function repairFolderOrders(){
      const db = readFolderDB();
      for (const f of db.folders){
        if (f.id === FOLDER_UNFILED_ID) f.order = 0;
        if (!Number.isFinite(f.order)) f.order = NaN;
      }
      const list = sortedFolders();
      let ord = 10;
      for (const f of list){
        if (f.id === FOLDER_UNFILED_ID){
          f.order = 0;
        } else {
          f.order = ord;
          ord += 10;
        }
      }
      db.folders = list;
      writeFolderDB(db);
    }

    function folderSet(){
      return new Set(sortedFolders().map(f => f.id));
    }

    function safeFolderId(id, set){
      if (id && set.has(id)) return id;
      return FOLDER_UNFILED_ID;
    }

    function folderNameMap(){
      const map = {};
      for (const f of sortedFolders()) map[f.id] = f.name;
      return map;
    }

    function folderOrderMap(){
      const map = {};
      for (const f of sortedFolders()) map[f.id] = (Number.isFinite(f.order) ? f.order : 1e18);
      return map;
    }

    // =========================
    // Scene DB (v2: order per scene)
    // =========================
    function emptySceneDB(){ return { version: 2, scenes: [] }; }

    function normalizeSceneObj(s){
      return {
        id: String(s?.id ?? uuid()),
        name: String(s?.name ?? "scene"),
        text: String(s?.text ?? ""),
        createdAt: String(s?.createdAt ?? s?.updatedAt ?? nowISO()),
        updatedAt: String(s?.updatedAt ?? nowISO()),
        fav: !!s?.fav,
        folderId: String(s?.folderId ?? FOLDER_UNFILED_ID),
        order: asNum(s?.order)
      };
    }

    function readSceneDB(){
      try{
        const raw = localStorage.getItem(LS_SCENE_DB);
        if (raw){
          const obj = JSON.parse(raw);
          const scenes = Array.isArray(obj?.scenes) ? obj.scenes : [];
          return { version: 2, scenes: scenes.map(normalizeSceneObj) };
        }
      } catch {}

      try{
        const raw = localStorage.getItem(LS_SCENE_DB_OLD);
        if (!raw) return emptySceneDB();
        const obj = JSON.parse(raw);
        const scenes = Array.isArray(obj?.scenes) ? obj.scenes : [];
        return { version: 2, scenes: scenes.map(normalizeSceneObj) };
      } catch {
        return emptySceneDB();
      }
    }

    function writeSceneDB(db){
      localStorage.setItem(LS_SCENE_DB, JSON.stringify({ version: 2, scenes: db.scenes }));
    }

    function sceneDraftKey(id){
      return id ? (LS_SCENE_DRAFT_PREFIX + id) : LS_SCENE_DRAFT_NEW;
    }
    function getSceneDraftRaw(id){
      return localStorage.getItem(sceneDraftKey(id));
    }
    function setSceneDraft(id, text){
      localStorage.setItem(sceneDraftKey(id), text ?? "");
    }
    function clearSceneDraft(id){
      localStorage.removeItem(sceneDraftKey(id));
    }

    function findSceneById(db, id){
      return db.scenes.find(s => s.id === id) || null;
    }

    function migrateVeryOldScenesIfNeeded(){
      const migrated = localStorage.getItem(LS_SCENE_MIGRATED) === "1";
      const db = readSceneDB();
      if (migrated || db.scenes.length > 0) return;

      let imported = 0;
      const existingNames = new Set();
      const newScenes = [];

      for (const key of OLD_SCENE_LIB_KEYS){
        const raw = localStorage.getItem(key);
        if (!raw) continue;
        try{
          const lib = JSON.parse(raw);
          if (!lib || typeof lib !== "object") continue;

          for (const [name0, payload] of Object.entries(lib)){
            const baseName = String(name0);
            const name = uniqueName(existingNames, baseName, "scene");
            existingNames.add(name);

            const text = String(payload?.text ?? "");
            const updatedAt = String(payload?.updatedAt ?? nowISO());
            const createdAt = String(payload?.createdAt ?? updatedAt);

            newScenes.push({
              id: uuid(),
              name,
              text,
              createdAt,
              updatedAt,
              fav: false,
              folderId: FOLDER_UNFILED_ID,
              order: NaN
            });
            imported++;
          }
        } catch {}
      }

      if (imported > 0){
        db.scenes = newScenes.map(normalizeSceneObj);
        writeSceneDB(db);

        let oldSelectedName = "";
        for (const k of OLD_SELECTED_NAME_KEYS){
          const v = localStorage.getItem(k);
          if (v) { oldSelectedName = v; break; }
        }
        if (oldSelectedName){
          const hit = db.scenes.find(s => s.name === oldSelectedName);
          if (hit) localStorage.setItem(LS_SCENE_SELECTED_ID, hit.id);
        }

        showToast(`æ—§ãƒ‡ãƒ¼ã‚¿ã‚’ç§»è¡Œã—ã¾ã—ãŸï¼ˆ${imported}ä»¶ï¼‰`);
      }

      localStorage.setItem(LS_SCENE_MIGRATED, "1");
    }

    function repairSceneFolderAndOrders(){
      const db = readSceneDB();
      const fset = folderSet();

      for (const s of db.scenes){
        s.folderId = safeFolderId(s.folderId, fset);
      }

      const folderIds = Array.from(fset);
      for (const fid of folderIds){
        const inFolder = db.scenes.filter(s => s.folderId === fid);
        if (inFolder.length === 0) continue;

        const anyInvalid = inFolder.some(s => !Number.isFinite(s.order));
        if (anyInvalid){
          let max = 0;
          for (const s of inFolder){
            if (Number.isFinite(s.order)) max = Math.max(max, s.order);
          }
          let next = (Number.isFinite(max) ? max : 0) + 10;

          for (const s of db.scenes){
            if (s.folderId !== fid) continue;
            if (!Number.isFinite(s.order)){
              s.order = next;
              next += 10;
            }
          }
        }

        const sorted = inFolder.slice().sort((a,b)=>{
          if (a.order !== b.order) return a.order - b.order;
          const ua = a.updatedAt ?? "";
          const ub = b.updatedAt ?? "";
          if (ua !== ub) return ua < ub ? 1 : -1;
          return (a.name ?? "").localeCompare((b.name ?? ""), "ja");
        });

        let ord = 10;
        for (const s of sorted){
          s.order = ord;
          ord += 10;
        }
      }

      writeSceneDB(db);
    }

    function sceneHasDirtyDraft(db, id){
      const s = findSceneById(db, id);
      if (!s) return false;
      const saved = s.text ?? "";
      const draft = getSceneDraftRaw(id);
      return draft !== null && draft !== saved;
    }

    // =========================
    // View logic
    // =========================
    function isReorderEnabled(){
      return sortMode === "manual" && (search.value.trim() === "");
    }

    // ãƒ•ã‚©ãƒ«ãƒ€è¦‹å‡ºã—ï¼‹æŠ˜ã‚ŠãŸãŸã¿ã‚’å‡ºã™æ¡ä»¶ï¼š
    // ã™ã¹ã¦ + æ‰‹å‹• + (æ¤œç´¢ãªã— OR ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ON)
    function isFolderChunkMode(){
      return folderFilterId === "ALL" && sortMode === "manual" && (search.value.trim() === "" || hasSearchScope());
    }

    function getListGroupForScene(s){
      if (favOnlyPref) return "fav";
      if (favPinPref) return (s.fav ? "fav" : "other");
      return "all";
    }

    function getSortedScenesForView(db){
      const fset = folderSet();

      let list = db.scenes.slice().map(normalizeSceneObj);
      for (const s of list) s.folderId = safeFolderId(s.folderId, fset);

      if (folderFilterId !== "ALL"){
        list = list.filter(s => s.folderId === folderFilterId);
      }

      const qRaw = search.value.trim();
      const q = qRaw.toLowerCase();

      // ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ï¼šå…¥åŠ›ãŒã‚ã‚‹æ™‚ã ã‘çµã‚‹ï¼ˆç©ºã®æ™‚ã¯è¦–ç•Œã‚’å¤‰ãˆãªã„ï¼‰
      if (q && folderFilterId === "ALL" && hasSearchScope()){
        list = list.filter(s => s.folderId === searchScopeFolderId);
      }

      if (q){
        list = list.filter(s => (s.name ?? "").toLowerCase().includes(q));
      }

      if (favOnlyPref){
        list = list.filter(s => !!s.fav);
      }

      if (sortMode === "updated"){
        list.sort((a,b)=>{
          const ua = a.updatedAt ?? "";
          const ub = b.updatedAt ?? "";
          if (ua !== ub) return ua < ub ? 1 : -1;
          return (a.name ?? "").localeCompare((b.name ?? ""), "ja");
        });
      } else if (sortMode === "name"){
        list.sort((a,b)=> (a.name ?? "").localeCompare((b.name ?? ""), "ja"));
      } else {
        const fOrder = folderOrderMap();
        list.sort((a,b)=>{
          const fa = (folderFilterId === "ALL") ? (fOrder[a.folderId] ?? 1e18) : 0;
          const fb = (folderFilterId === "ALL") ? (fOrder[b.folderId] ?? 1e18) : 0;
          if (fa !== fb) return fa - fb;

          const ao = Number.isFinite(a.order) ? a.order : 1e18;
          const bo = Number.isFinite(b.order) ? b.order : 1e18;
          if (ao !== bo) return ao - bo;

          const ua = a.updatedAt ?? "";
          const ub = b.updatedAt ?? "";
          if (ua !== ub) return ua < ub ? 1 : -1;
          return (a.name ?? "").localeCompare((b.name ?? ""), "ja");
        });
      }

      return list;
    }

    let renderScheduled = false;
    function scheduleRenderSceneList(){
      if (renderScheduled) return;
      renderScheduled = true;
      requestAnimationFrame(() => {
        renderScheduled = false;
        renderSceneList();
      });
    }

    function updateFolderChunkControls(){
      // â€œå…¨æŠ˜/å…¨å±•â€ã¯ã€è¤‡æ•°ãƒ•ã‚©ãƒ«ãƒ€ã‚’çœºã‚ã‚‹æ™‚ã ã‘å‡ºã™ï¼ˆæ¤œç´¢ä¸­ã¯ãƒã‚¤ã‚ºï¼‰
      const on = isFolderChunkMode() && (search.value.trim() === "");
      folderCollapseAllBtn.style.display = on ? "inline-flex" : "none";
      folderExpandAllBtn.style.display = on ? "inline-flex" : "none";
    }

    function updateLibraryHint(){
      const reorder = isReorderEnabled();
      const chunk = isFolderChunkMode();
      const scoped = (folderFilterId === "ALL" && hasSearchScope());

      if (chunk){
        const extra = scoped ? "ï¼ˆğŸ”é™å®šä¸­ï¼‰" : "";
        libraryHint.innerHTML =
          `ğŸ“è¦‹å‡ºã—ã§â€œã‹ãŸã¾ã‚ŠåŒ–â€${extra}ã€‚è¦‹å‡ºã—ã‚¯ãƒªãƒƒã‚¯=æŠ˜/å±•é–‹ã€<strong>ğŸ”=ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã ã‘æ¤œç´¢</strong>ã€<strong>ï¼‹=ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã«æ–°è¦</strong>ã€‚â‰¡ã§ä¸¦ã³æ›¿ãˆï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã¿ï¼‰ã€‚`;
        return;
      }

      libraryHint.innerHTML = reorder
        ? `ğŸ“ã§çµã‚Šè¾¼ã¿ã€‚â˜…ã§ãŠæ°—ã«å…¥ã‚Šã€‚â‰¡ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã³æ›¿ãˆï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã¿ï¼‰ã€‚`
        : `â˜…ã§ãŠæ°—ã«å…¥ã‚Šã€‚ä¸¦ã³æ›¿ãˆã¯ <strong>æ‰‹å‹•</strong> ã‹ã¤ <strong>æ¤œç´¢ãŒç©º</strong> ã®ã¨ãã ã‘æœ‰åŠ¹ã§ã™ã€‚`;
    }

    function clearDropIndicator(){
      if (dropEl){
        dropEl.classList.remove("drop-before","drop-after");
        dropEl = null;
      }
    }
    function shouldSuppressClick(){
      return Date.now() < suppressClickUntil;
    }

    // =========================
    // Scene reorder (per-folder)
    // =========================
    function reorderWithinFolder(dragId, targetId, pos, group, folderId){
      const db = readSceneDB();
      const fset = folderSet();

      const fid = safeFolderId(folderId, fset);
      const folderScenes = db.scenes
        .filter(s => safeFolderId(s.folderId, fset) === fid)
        .map(normalizeSceneObj)
        .sort((a,b)=> a.order - b.order);

      if (folderScenes.length === 0) return;

      const groupMatch = (s) => {
        if (group === "fav") return !!s.fav;
        if (group === "other") return !s.fav;
        return true;
      };

      const groupIndices = [];
      for (let i=0;i<folderScenes.length;i++){
        if (groupMatch(folderScenes[i])) groupIndices.push(i);
      }

      const fromAll = folderScenes.findIndex(s => s.id === dragId);
      const toAll = folderScenes.findIndex(s => s.id === targetId);
      if (fromAll < 0 || toAll < 0) return;
      if (!groupIndices.includes(fromAll) || !groupIndices.includes(toAll)) return;

      const groupIds = groupIndices.map(i => folderScenes[i].id);
      const fromG = groupIds.indexOf(dragId);
      const toG = groupIds.indexOf(targetId);
      if (fromG < 0 || toG < 0) return;

      const [moved] = groupIds.splice(fromG, 1);
      let insert = toG;
      if (fromG < toG) insert--;
      if (pos === "after") insert++;
      groupIds.splice(insert, 0, moved);

      const idToObj = new Map(db.scenes.map(s=>[s.id, s]));
      for (let k=0;k<groupIndices.length;k++){
        const idx = groupIndices[k];
        const sid = groupIds[k];
        const real = idToObj.get(sid);
        if (real) folderScenes[idx] = normalizeSceneObj(real);
      }

      let ord = 10;
      for (const s of folderScenes){
        const real = idToObj.get(s.id);
        if (real){
          real.order = ord;
          ord += 10;
        }
      }

      writeSceneDB(db);
      showToast("ä¸¦ã³æ›¿ãˆã¾ã—ãŸ");
      scheduleRenderSceneList();
    }

    // =========================
    // Scene insert/move (order-safe)
    // =========================
    function insertNewSceneIntoFolder(db, newObj, afterSceneIdOrNull){
      const fset = folderSet();
      newObj.folderId = safeFolderId(newObj.folderId, fset);

      db.scenes.push(newObj);

      const fid = newObj.folderId;
      const folderScenes = db.scenes
        .filter(s => safeFolderId(s.folderId, fset) === fid)
        .sort((a,b)=>{
          const ao = Number.isFinite(a.order) ? a.order : 1e18;
          const bo = Number.isFinite(b.order) ? b.order : 1e18;
          return ao - bo;
        });

      let insertIndex = 0;
      if (afterSceneIdOrNull){
        const idx = folderScenes.findIndex(s => s.id === afterSceneIdOrNull);
        if (idx >= 0) insertIndex = idx + 1;
      }

      const curIdx = folderScenes.findIndex(s => s.id === newObj.id);
      if (curIdx >= 0) folderScenes.splice(curIdx, 1);
      folderScenes.splice(insertIndex, 0, newObj);

      let ord = 10;
      for (const s of folderScenes){
        s.order = ord;
        ord += 10;
      }
    }

    function moveSceneToFolder(sceneId, newFolderId){
      const db = readSceneDB();
      const fset = folderSet();

      const s = findSceneById(db, sceneId);
      if (!s) return;

      const oldFolder = safeFolderId(s.folderId, fset);
      const newFolder = safeFolderId(newFolderId, fset);
      if (oldFolder === newFolder) return;

      const oldList = db.scenes
        .filter(x => safeFolderId(x.folderId, fset) === oldFolder && x.id !== sceneId)
        .sort((a,b)=> (Number.isFinite(a.order)?a.order:1e18) - (Number.isFinite(b.order)?b.order:1e18));

      let ord = 10;
      for (const x of oldList){
        x.order = ord;
        ord += 10;
      }

      s.folderId = newFolder;

      const newList = db.scenes
        .filter(x => safeFolderId(x.folderId, fset) === newFolder)
        .sort((a,b)=> (Number.isFinite(a.order)?a.order:1e18) - (Number.isFinite(b.order)?b.order:1e18));

      const movedIdx = newList.findIndex(x => x.id === sceneId);
      if (movedIdx >= 0) newList.splice(movedIdx, 1);
      newList.push(s);

      ord = 10;
      for (const x of newList){
        x.order = ord;
        ord += 10;
      }

      writeSceneDB(db);

      if (folderFilterId !== "ALL" && folderFilterId === oldFolder){
        folderFilterId = newFolder;
        localStorage.setItem(LS_UI_FOLDER_FILTER, folderFilterId);
        renderFolderFilterSelect();
      }

      expandFolderForSceneId(sceneId);
      scrollToActiveNext = true;

      updateSceneUI();
      scheduleRenderSceneList();
      showToast("ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç§»å‹•ã—ã¾ã—ãŸ");
    }

    function toggleSceneFavorite(id){
      const db = readSceneDB();
      const s = findSceneById(db, id);
      if (!s) return;
      s.fav = !s.fav;
      writeSceneDB(db);
      updateSceneUI();
      scheduleRenderSceneList();
      showToast(s.fav ? "ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ " : "ãŠæ°—ã«å…¥ã‚Šè§£é™¤");
    }

    // =========================
    // Render: Scene item
    // =========================
    function renderSceneItem(s, folderMap, showFolderInMeta){
      const group = getListGroupForScene(s);
      const canReorder = isReorderEnabled();

      const row = document.createElement("div");
      row.className = "sceneItem" + ((s.id === currentSceneId) ? " active" : "");
      row.dataset.id = s.id;
      row.dataset.group = group;
      row.dataset.folderId = s.folderId;
      row.tabIndex = 0;
      row.setAttribute("role","button");

      const folderName = folderMap[s.folderId] ?? "æœªåˆ†é¡";
      row.title = `${s.name}\næ›´æ–°: ${formatUpdated(s.updatedAt)}\nãƒ•ã‚©ãƒ«ãƒ€: ${folderName}`;

      row.addEventListener("click", () => {
        if (shouldSuppressClick()) return;
        selectSceneById(s.id);
      });
      row.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          if (shouldSuppressClick()) return;
          selectSceneById(s.id);
        }
      });

      row.addEventListener("dragover", (e) => {
        if (!dragState) return;
        if (!canReorder) return;

        const targetId = row.dataset.id;
        const targetGroup = row.dataset.group;
        const targetFolderId = row.dataset.folderId;

        if (!targetId || targetId === dragState.id) return;
        if (targetGroup !== dragState.group) return;
        if (targetFolderId !== dragState.folderId) return;

        e.preventDefault();
        const rect = row.getBoundingClientRect();
        const mid = rect.top + rect.height/2;
        const pos = (e.clientY < mid) ? "before" : "after";

        if (dropEl && dropEl !== row) dropEl.classList.remove("drop-before","drop-after");
        dropEl = row;
        dropPos = pos;
        row.classList.toggle("drop-before", pos === "before");
        row.classList.toggle("drop-after", pos === "after");
        e.dataTransfer.dropEffect = "move";
      });

      row.addEventListener("drop", (e) => {
        if (!dragState) return;
        if (!canReorder) return;

        const targetId = row.dataset.id;
        const targetGroup = row.dataset.group;
        const targetFolderId = row.dataset.folderId;

        if (!targetId || targetId === dragState.id) return;
        if (targetGroup !== dragState.group) return;
        if (targetFolderId !== dragState.folderId) return;

        e.preventDefault();
        reorderWithinFolder(dragState.id, targetId, dropPos, dragState.group, dragState.folderId);
        dragState = null;
        clearDropIndicator();
      });

      const left = document.createElement("div");
      left.className = "sceneLeft";

      const name = document.createElement("div");
      name.className = "sceneName";
      name.textContent = s.name ?? "(no name)";

      const meta = document.createElement("div");
      meta.className = "sceneMeta";
      meta.textContent = showFolderInMeta
        ? `æ›´æ–°: ${formatUpdated(s.updatedAt)} ï½œ ğŸ“ ${folderName}`
        : `æ›´æ–°: ${formatUpdated(s.updatedAt)}`;

      left.appendChild(name);
      left.appendChild(meta);

      const right = document.createElement("div");
      right.className = "sceneRight";

      const star = document.createElement("button");
      star.type = "button";
      star.className = "iconBtn starBtn" + (s.fav ? " active" : "");
      star.textContent = s.fav ? "â˜…" : "â˜†";
      star.title = s.fav ? "ãŠæ°—ã«å…¥ã‚Šè§£é™¤" : "ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ";
      star.setAttribute("aria-label", star.title);
      star.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleSceneFavorite(s.id);
      });

      const dot = document.createElement("div");
      dot.className = "dot" + (sceneHasDirtyDraft(readSceneDB(), s.id) ? " draft" : "");
      dot.title = dot.classList.contains("draft") ? "æœªä¿å­˜ã®ä¸‹æ›¸ãã‚ã‚Š" : "";

      const handle = document.createElement("button");
      handle.type = "button";
      handle.className = "iconBtn dragHandle" + (canReorder ? "" : " disabled");
      handle.textContent = "â‰¡";
      handle.title = canReorder ? "ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³æ›¿ãˆï¼ˆåŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã¿ï¼‰" : "ä¸¦ã³æ›¿ãˆä¸å¯ï¼ˆæ‰‹å‹•ï¼†æ¤œç´¢ãªã—ï¼‰";
      handle.setAttribute("aria-label", handle.title);
      handle.draggable = !!canReorder;

      handle.addEventListener("click", (e) => e.stopPropagation());

      handle.addEventListener("dragstart", (e) => {
        if (!canReorder){
          e.preventDefault();
          return;
        }
        dragState = { id: s.id, group, folderId: s.folderId };
        suppressClickUntil = Date.now() + 600;

        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", s.id);

        const item = handle.closest(".sceneItem");
        if (item) item.classList.add("dragging");
      });

      handle.addEventListener("dragend", () => {
        const item = handle.closest(".sceneItem");
        if (item) item.classList.remove("dragging");
        dragState = null;
        clearDropIndicator();
        suppressClickUntil = Date.now() + 200;
      });

      right.appendChild(star);
      right.appendChild(dot);
      right.appendChild(handle);

      row.appendChild(left);
      row.appendChild(right);

      return row;
    }

    function renderSectionHeader(text){
      const h = document.createElement("div");
      h.className = "sectionHeader";
      h.textContent = text;
      return h;
    }

    function renderFlatList(parent, scenes, folderMap, showFolderInMeta){
      const sub = document.createElement("div");
      sub.className = "sublist";
      for (const s of scenes){
        sub.appendChild(renderSceneItem(s, folderMap, showFolderInMeta));
      }
      parent.appendChild(sub);
    }

    function newSceneInFolder(fid){
      const set = folderSet();
      if (!set.has(fid)) return;

      newSceneFolderId = fid;
      localStorage.setItem(LS_UI_NEW_SCENE_FOLDER, newSceneFolderId);

      // è¿·å­é˜²æ­¢ï¼šæ–°è¦ã‚’ä½œã‚‹ãƒ•ã‚©ãƒ«ãƒ€ã¯å±•é–‹
      if (folderCollapseMap[fid]){
        delete folderCollapseMap[fid];
        saveFolderCollapseMap();
      }

      const name = folderNameMap()[fid] ?? "æœªåˆ†é¡";
      nextNewSceneToast = `æ–°è¦ï¼ˆä¿å­˜å…ˆï¼š${name}ï¼‰`;
      newScene();
    }

    function renderFolderHeader(folder, count, collapsed, containsActive, isScoped){
      const h = document.createElement("div");
      h.className = "folderHeader" + (containsActive ? " active" : "");
      h.dataset.folderId = folder.id;
      h.tabIndex = 0;
      h.setAttribute("role","button");
      h.title = "ã‚¯ãƒªãƒƒã‚¯ã§æŠ˜ã‚ŠãŸãŸã¿/å±•é–‹";

      const left = document.createElement("div");
      left.className = "fhLeft";

      const caret = document.createElement("div");
      caret.className = "fhCaret";
      caret.textContent = collapsed ? "â–¸" : "â–¾";

      const name = document.createElement("div");
      name.className = "fhName";
      name.textContent = `ğŸ“ ${folder.name}`;

      left.appendChild(caret);
      left.appendChild(name);

      const right = document.createElement("div");
      right.className = "fhRight";

      if (containsActive){
        const dot = document.createElement("div");
        dot.className = "fhDot";
        dot.title = "é¸æŠä¸­ã®ã‚·ãƒ¼ãƒ³ãŒã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã«ã‚ã‚Šã¾ã™";
        right.appendChild(dot);
      }

      const c = document.createElement("div");
      c.className = "fhCount";
      c.textContent = `${count}ä»¶`;
      right.appendChild(c);

      // ğŸ” ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã ã‘æ¤œç´¢ï¼ˆãƒˆã‚°ãƒ«ï¼‰
      const scopeBtn = document.createElement("button");
      scopeBtn.type = "button";
      scopeBtn.className = "iconBtn scopeBtn" + (isScoped ? " active" : "");
      scopeBtn.textContent = "ğŸ”";
      scopeBtn.title = isScoped ? "ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã ã‘æ¤œç´¢ï¼šè§£é™¤" : "ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã ã‘æ¤œç´¢ï¼ˆæ¤œç´¢æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼‰";
      scopeBtn.setAttribute("aria-label", scopeBtn.title);
      scopeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleSearchScope(folder.id);
      });
      right.appendChild(scopeBtn);

      // ï¼‹ ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã«æ–°è¦
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "iconBtn";
      addBtn.textContent = "ï¼‹";
      addBtn.title = "ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã«æ–°è¦ã‚·ãƒ¼ãƒ³";
      addBtn.setAttribute("aria-label", addBtn.title);
      addBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        newSceneInFolder(folder.id);
      });
      right.appendChild(addBtn);

      h.appendChild(left);
      h.appendChild(right);

      h.addEventListener("click", () => {
        toggleFolderCollapsed(folder.id);
        scheduleRenderSceneList();
      });
      h.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          toggleFolderCollapsed(folder.id);
          scheduleRenderSceneList();
        }
      });

      return h;
    }

    function renderChunkedByFolder(parent, scenes, folderMap){
      const folders = sortedFolders();
      const byFolder = new Map();
      for (const s of scenes){
        if (!byFolder.has(s.folderId)) byFolder.set(s.folderId, []);
        byFolder.get(s.folderId).push(s);
      }

      const searchingNow = search.value.trim() !== "";

      for (const f of folders){
        const arr = byFolder.get(f.id);
        if (!arr || arr.length === 0) continue;

        const containsActive = !!(currentSceneId && arr.some(x => x.id === currentSceneId));
        const scoped = (folderFilterId === "ALL" && hasSearchScope() && searchScopeFolderId === f.id);

        // æ¤œç´¢ä¸­ã¯çµæœã‚’è¦‹å¤±ã‚ãªã„ã‚ˆã†ã«â€œè¡¨ç¤ºä¸Šã¯å±•é–‹â€
        const collapsed = searchingNow ? false : isFolderCollapsed(f.id);

        parent.appendChild(renderFolderHeader(f, arr.length, collapsed, containsActive, scoped));

        if (!collapsed){
          renderFlatList(parent, arr, folderMap, false);
        }
      }
    }

    // =========================
    // Render: Scene list main
    // =========================
    function renderSceneList(){
      const db = readSceneDB();
      const folderMap = folderNameMap();

      sanitizeSearchScope();
      updateSearchScopeBadge(folderMap);

      const viewList = getSortedScenesForView(db);

      const total = db.scenes.length;
      const favCount = db.scenes.filter(s => !!s.fav).length;
      sceneCount.textContent = `${viewList.length}ä»¶ï¼ˆå…¨${total} / â˜…${favCount}ï¼‰`;

      deleteSceneBtn.disabled = (currentSceneId === null);
      updateFolderChunkControls();
      updateLibraryHint();

      const chunkMode = isFolderChunkMode();
      const searchingNow = search.value.trim() !== "";

      // chunkModeã®ã¨ãã¯è¦‹å‡ºã—ãŒã‚ã‚‹ã®ã§ã€ã‚¢ã‚¤ãƒ†ãƒ å´ã«ã¯ãƒ•ã‚©ãƒ«ãƒ€è¡¨ç¤ºã‚’çœç•¥
      const showFolderInMetaFlat = (folderFilterId === "ALL" && !chunkMode);

      const scrollTop = sceneList.scrollTop;
      sceneList.innerHTML = "";

      if (viewList.length === 0){
        const empty = document.createElement("div");
        empty.className = "emptyState";
        empty.textContent =
          favOnlyPref ? "ãŠæ°—ã«å…¥ã‚Šï¼ˆâ˜…ï¼‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšâ˜…ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚"
          : "è©²å½“ã™ã‚‹ã‚·ãƒ¼ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ¡ä»¶ã‚’å¤‰ãˆã‚‹ã‹ã€Œæ–°è¦ã€ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚";
        sceneList.appendChild(empty);
        sceneList.scrollTop = scrollTop;
        return;
      }

      // æ¤œç´¢ä¸­ã¯â€œåˆ†å‰²è¡¨ç¤ºâ€ã‚’æŠ‘åˆ¶ï¼ˆè¦‹ãŸç›®ã®ãƒã‚¤ã‚ºã¨è¦–ç·šã‚¸ãƒ£ãƒ³ãƒ—ã‚’æ¸›ã‚‰ã™ï¼‰
      const useFavPinGrouping = (favPinPref && !favOnlyPref && !searchingNow);

      if (useFavPinGrouping){
        const favs = viewList.filter(s => !!s.fav);
        const others = viewList.filter(s => !s.fav);

        if (favs.length > 0){
          sceneList.appendChild(renderSectionHeader("â˜… ãŠæ°—ã«å…¥ã‚Šï¼ˆå³ã‚¢ã‚¯ã‚»ã‚¹ï¼‰"));
          renderFlatList(sceneList, favs, folderMap, (folderFilterId === "ALL"));
        }

        sceneList.appendChild(renderSectionHeader("ã™ã¹ã¦"));

        if (chunkMode){
          renderChunkedByFolder(sceneList, others, folderMap);
        } else {
          renderFlatList(sceneList, others, folderMap, showFolderInMetaFlat);
        }
      } else {
        if (chunkMode){
          renderChunkedByFolder(sceneList, viewList, folderMap);
        } else {
          renderFlatList(sceneList, viewList, folderMap, showFolderInMetaFlat);
        }
      }

      if (scrollToActiveNext){
        const activeEl = sceneList.querySelector(".sceneItem.active");
        if (activeEl) activeEl.scrollIntoView({ block: "nearest" });
        scrollToActiveNext = false;
      } else {
        sceneList.scrollTop = scrollTop;
      }
    }

    // =========================
    // Folder selects + manager UI
    // =========================
    function renderFolderFilterSelect(){
      const folders = sortedFolders();

      if (folderFilterId !== "ALL" && !folders.some(f => f.id === folderFilterId)){
        folderFilterId = "ALL";
        localStorage.setItem(LS_UI_FOLDER_FILTER, folderFilterId);
      }

      folderFilter.innerHTML = "";
      const optAll = document.createElement("option");
      optAll.value = "ALL";
      optAll.textContent = "ã™ã¹ã¦ï¼ˆå…¨ãƒ•ã‚©ãƒ«ãƒ€ï¼‰";
      folderFilter.appendChild(optAll);

      for (const f of folders){
        const opt = document.createElement("option");
        opt.value = f.id;
        opt.textContent = `ğŸ“ ${f.name}`;
        folderFilter.appendChild(opt);
      }

      folderFilter.value = folderFilterId;
    }

    function renderSceneFolderSelect(){
      const folders = sortedFolders();
      const fset = new Set(folders.map(f=>f.id));

      sceneFolderSelect.innerHTML = "";
      for (const f of folders){
        const opt = document.createElement("option");
        opt.value = f.id;
        opt.textContent = `ğŸ“ ${f.name}`;
        sceneFolderSelect.appendChild(opt);
      }

      let fid = FOLDER_UNFILED_ID;
      if (currentSceneId === null){
        fid = safeFolderId(newSceneFolderId, fset);
      } else {
        const db = readSceneDB();
        const s = findSceneById(db, currentSceneId);
        fid = safeFolderId(s?.folderId, fset);
      }
      sceneFolderSelect.value = fid;
    }

    function folderCountsById(dbScenes){
      const fset = folderSet();
      const counts = {};
      for (const fid of fset) counts[fid] = 0;
      for (const s of dbScenes){
        const fid = safeFolderId(s.folderId, fset);
        counts[fid] = (counts[fid] ?? 0) + 1;
      }
      return counts;
    }

    function openFolderDialog(){
      renderFolderManagerList();
      if (typeof folderDialog.showModal === "function") folderDialog.showModal();
      else folderDialog.setAttribute("open", "open");
    }
    function closeFolderDialog(){
      if (folderDialog.open) folderDialog.close();
      else folderDialog.removeAttribute("open");
    }

    function clearFolderDropIndicator(){
      if (folderDropEl){
        folderDropEl.classList.remove("drop-before","drop-after");
        folderDropEl = null;
      }
    }

    function reorderFolders(dragId, targetId, pos){
      if (!dragId || !targetId || dragId === targetId) return;
      if (dragId === FOLDER_UNFILED_ID || targetId === FOLDER_UNFILED_ID) return;

      const db = readFolderDB();
      const list = sortedFolders().filter(f => f.id !== FOLDER_UNFILED_ID).map(f => f.id);

      const from = list.indexOf(dragId);
      const to = list.indexOf(targetId);
      if (from < 0 || to < 0) return;

      const [moved] = list.splice(from, 1);
      let insert = to;
      if (from < to) insert--;
      if (pos === "after") insert++;
      list.splice(insert, 0, moved);

      const unfiled = db.folders.find(f => f.id === FOLDER_UNFILED_ID) ?? { id:FOLDER_UNFILED_ID, name:"æœªåˆ†é¡", createdAt: nowISO(), updatedAt: nowISO(), order:0 };
      unfiled.order = 0;

      const map = new Map(db.folders.map(f => [f.id, f]));
      const newFolders = [unfiled];

      let ord = 10;
      for (const id of list){
        const f = map.get(id);
        if (!f) continue;
        f.order = ord;
        ord += 10;
        newFolders.push(f);
      }

      for (const f of db.folders){
        if (!newFolders.some(x => x.id === f.id)){
          if (f.id === FOLDER_UNFILED_ID) continue;
          f.order = ord;
          ord += 10;
          newFolders.push(f);
        }
      }

      db.folders = newFolders;
      writeFolderDB(db);

      renderFolderFilterSelect();
      renderSceneFolderSelect();
      renderFolderManagerList();
      scheduleRenderSceneList();
      showToast("ãƒ•ã‚©ãƒ«ãƒ€é †ã‚’å¤‰æ›´ã—ã¾ã—ãŸ");
    }

    function renderFolderManagerList(){
      const folders = sortedFolders();
      const db = readSceneDB();
      const counts = folderCountsById(db.scenes);

      folderListEl.innerHTML = "";

      for (const f of folders){
        const row = document.createElement("div");
        row.className = "folderRow";
        row.dataset.folderId = f.id;

        const left = document.createElement("div");
        left.className = "folderLeft";

        const name = document.createElement("div");
        name.className = "folderName";
        name.textContent = (f.id === FOLDER_UNFILED_ID) ? `æœªåˆ†é¡ï¼ˆå›ºå®šï¼‰` : f.name;

        const meta = document.createElement("div");
        meta.className = "folderMeta";
        meta.textContent = `ã‚·ãƒ¼ãƒ³æ•°: ${counts[f.id] ?? 0}`;

        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement("div");
        right.className = "folderRight";

        const handle = document.createElement("button");
        handle.type = "button";
        handle.className = "iconBtn folderHandle" + ((f.id === FOLDER_UNFILED_ID) ? " disabled" : "");
        handle.textContent = "â‰¡";
        handle.title = (f.id === FOLDER_UNFILED_ID) ? "æœªåˆ†é¡ã¯å›ºå®šã§ã™" : "ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã³æ›¿ãˆ";
        handle.setAttribute("aria-label", handle.title);
        handle.draggable = (f.id !== FOLDER_UNFILED_ID);

        handle.addEventListener("dragstart", (e) => {
          if (f.id === FOLDER_UNFILED_ID){
            e.preventDefault();
            return;
          }
          folderDragId = f.id;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", f.id);
        });

        handle.addEventListener("dragend", () => {
          folderDragId = null;
          clearFolderDropIndicator();
        });

        row.addEventListener("dragover", (e) => {
          if (!folderDragId) return;
          if (f.id === FOLDER_UNFILED_ID) return;
          if (folderDragId === f.id) return;

          e.preventDefault();

          const rect = row.getBoundingClientRect();
          const mid = rect.top + rect.height/2;
          const pos = (e.clientY < mid) ? "before" : "after";

          if (folderDropEl && folderDropEl !== row){
            folderDropEl.classList.remove("drop-before","drop-after");
          }
          folderDropEl = row;
          folderDropPos = pos;
          row.classList.toggle("drop-before", pos === "before");
          row.classList.toggle("drop-after", pos === "after");
          e.dataTransfer.dropEffect = "move";
        });

        row.addEventListener("drop", (e) => {
          if (!folderDragId) return;
          if (f.id === FOLDER_UNFILED_ID) return;
          e.preventDefault();
          reorderFolders(folderDragId, f.id, folderDropPos);
          folderDragId = null;
          clearFolderDropIndicator();
        });

        const rename = document.createElement("button");
        rename.type = "button";
        rename.className = "btn small";
        rename.textContent = "åå‰å¤‰æ›´";
        rename.disabled = (f.id === FOLDER_UNFILED_ID);
        rename.title = rename.disabled ? "æœªåˆ†é¡ã¯å›ºå®šã§ã™" : "åå‰å¤‰æ›´";
        rename.addEventListener("click", () => renameFolder(f.id));

        const del = document.createElement("button");
        del.type = "button";
        del.className = "btn small danger";
        del.textContent = "å‰Šé™¤";
        del.disabled = (f.id === FOLDER_UNFILED_ID);
        del.title = del.disabled ? "æœªåˆ†é¡ã¯å‰Šé™¤ã§ãã¾ã›ã‚“" : "å‰Šé™¤ï¼ˆä¸­èº«ã¯æœªåˆ†é¡ã¸ç§»å‹•ï¼‰";
        del.addEventListener("click", () => deleteFolder(f.id));

        right.appendChild(handle);
        right.appendChild(rename);
        right.appendChild(del);

        row.appendChild(left);
        row.appendChild(right);
        folderListEl.appendChild(row);
      }
    }

    function createFolder(){
      const db = readFolderDB();
      const name0 = (prompt("ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", "") ?? "").trim();
      if (!name0){ showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«"); return; }

      const existing = new Set(db.folders.map(f=>f.name));
      const finalName = uniqueName(existing, name0, "ãƒ•ã‚©ãƒ«ãƒ€");

      const maxOrder = Math.max(0, ...db.folders.filter(f=>f.id!==FOLDER_UNFILED_ID).map(f=>Number.isFinite(f.order)?f.order:0));
      db.folders.push({
        id: uuid(),
        name: finalName,
        createdAt: nowISO(),
        updatedAt: nowISO(),
        order: maxOrder + 10
      });
      writeFolderDB(db);
      repairFolderOrders();

      renderFolderFilterSelect();
      renderSceneFolderSelect();
      renderFolderManagerList();
      scheduleRenderSceneList();
      showToast(`ãƒ•ã‚©ãƒ«ãƒ€ä½œæˆ: ${finalName}`);
    }

    function renameFolder(folderId){
      if (folderId === FOLDER_UNFILED_ID) return;
      const db = readFolderDB();
      const folder = db.folders.find(f => f.id === folderId);
      if (!folder) return;

      const name0 = (prompt("æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", folder.name) ?? "").trim();
      if (!name0){ showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«"); return; }

      const existing = new Set(db.folders.filter(f=>f.id!==folderId).map(f=>f.name));
      const finalName = uniqueName(existing, name0, "ãƒ•ã‚©ãƒ«ãƒ€");
      folder.name = finalName;
      folder.updatedAt = nowISO();
      writeFolderDB(db);

      renderFolderFilterSelect();
      renderSceneFolderSelect();
      renderFolderManagerList();
      scheduleRenderSceneList();
      showToast("ãƒ•ã‚©ãƒ«ãƒ€åã‚’å¤‰æ›´ã—ã¾ã—ãŸ");
    }

    function deleteFolder(folderId){
      if (folderId === FOLDER_UNFILED_ID) return;

      const fdb = readFolderDB();
      const folder = fdb.folders.find(f => f.id === folderId);
      if (!folder) return;

      const ok = confirm(`ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${folder.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nä¸­ã®ã‚·ãƒ¼ãƒ³ã¯æœªåˆ†é¡ã«ç§»å‹•ã—ã¾ã™ã€‚`);
      if (!ok) return;

      const db = readSceneDB();
      const fset = folderSet();

      const moved = db.scenes
        .filter(s => safeFolderId(s.folderId, fset) === folderId)
        .sort((a,b)=> (Number.isFinite(a.order)?a.order:1e18) - (Number.isFinite(b.order)?b.order:1e18));

      for (const s of moved){
        s.folderId = FOLDER_UNFILED_ID;
      }

      const unfiledList = db.scenes
        .filter(s => safeFolderId(s.folderId, fset) === FOLDER_UNFILED_ID)
        .sort((a,b)=> (Number.isFinite(a.order)?a.order:1e18) - (Number.isFinite(b.order)?b.order:1e18));

      let ord = 10;
      for (const s of unfiledList){
        s.order = ord;
        ord += 10;
      }

      writeSceneDB(db);

      fdb.folders = fdb.folders.filter(f => f.id !== folderId);
      writeFolderDB(fdb);
      repairFolderOrders();

      delete folderCollapseMap[folderId];
      saveFolderCollapseMap();

      if (searchScopeFolderId === folderId){
        setSearchScope("");
      }

      if (folderFilterId === folderId){
        folderFilterId = "ALL";
        localStorage.setItem(LS_UI_FOLDER_FILTER, folderFilterId);
      }
      if (newSceneFolderId === folderId){
        newSceneFolderId = FOLDER_UNFILED_ID;
        localStorage.setItem(LS_UI_NEW_SCENE_FOLDER, newSceneFolderId);
      }

      renderFolderFilterSelect();
      renderSceneFolderSelect();
      renderFolderManagerList();
      scheduleRenderSceneList();
      showToast(`å‰Šé™¤ã—ã¾ã—ãŸï¼ˆæœªåˆ†é¡ã¸ ${moved.length}ä»¶ç§»å‹•ï¼‰`);
    }

    // =========================
    // UI: Library drawer/compact
    // =========================
    function isMobile(){
      return window.matchMedia("(max-width: 980px)").matches;
    }
    function effectiveCollapsed(){
      return collapsedPref || isMobile();
    }
    function setLibraryOpen(open){
      if (!document.body.classList.contains("lib-collapsed")) return;
      document.body.classList.toggle("lib-open", !!open);
      updateLibraryToggleLabel();
      if (open) setTimeout(() => search.focus(), 0);
    }
    function updateLibraryToggleLabel(){
      const collapsed = document.body.classList.contains("lib-collapsed");
      if (!collapsed){
        libraryToggle.textContent = "ä¸€è¦§ã‚’éš ã™";
        return;
      }
      const open = document.body.classList.contains("lib-open");
      libraryToggle.textContent = open ? "ä¸€è¦§ã‚’é–‰ã˜ã‚‹" : "ä¸€è¦§ã‚’é–‹ã";
    }
    function applyLibraryLayout(){
      document.body.classList.toggle("is-mobile", isMobile());
      document.body.classList.toggle("compact", !!compactPref);

      const collapsed = effectiveCollapsed();
      document.body.classList.toggle("lib-collapsed", collapsed);

      if (!collapsed) document.body.classList.remove("lib-open");

      updateLibraryToggleLabel();

      compactToggle.checked = !!compactPref;
      favPinToggle.checked = !!favPinPref;
      favOnlyToggle.checked = !!favOnlyPref;

      if (!["manual","updated","name"].includes(sortMode)) sortMode = "manual";
      sortSelect.value = sortMode;

      renderFolderFilterSelect();
      renderSceneFolderSelect();
      updateFolderChunkControls();
      updateLibraryHint();
    }

    libraryToggle.addEventListener("click", () => {
      const collapsed = document.body.classList.contains("lib-collapsed");

      if (!collapsed && !isMobile()){
        collapsedPref = true;
        localStorage.setItem(LS_UI_COLLAPSED, "1");
        applyLibraryLayout();
        showToast("ä¸€è¦§ã‚’éš ã—ã¾ã—ãŸ");
        return;
      }

      const open = document.body.classList.contains("lib-open");
      setLibraryOpen(!open);
    });

    backdrop.addEventListener("click", () => setLibraryOpen(false));
    libraryClose.addEventListener("click", () => setLibraryOpen(false));

    libraryDock.addEventListener("click", () => {
      if (isMobile()) return;
      collapsedPref = false;
      localStorage.setItem(LS_UI_COLLAPSED, "0");
      applyLibraryLayout();
      showToast("ä¸€è¦§ã‚’å›ºå®šè¡¨ç¤ºã«æˆ»ã—ã¾ã—ãŸ");
    });

    compactToggle.addEventListener("change", () => {
      compactPref = !!compactToggle.checked;
      localStorage.setItem(LS_UI_COMPACT, compactPref ? "1" : "0");
      applyLibraryLayout();
      scheduleRenderSceneList();
    });

    favPinToggle.addEventListener("change", () => {
      favPinPref = !!favPinToggle.checked;
      localStorage.setItem(LS_UI_FAV_PIN, favPinPref ? "1" : "0");
      scheduleRenderSceneList();
    });

    favOnlyToggle.addEventListener("change", () => {
      favOnlyPref = !!favOnlyToggle.checked;
      localStorage.setItem(LS_UI_FAV_ONLY, favOnlyPref ? "1" : "0");
      scheduleRenderSceneList();
    });

    sortSelect.addEventListener("change", () => {
      sortMode = sortSelect.value;
      localStorage.setItem(LS_UI_SORT, sortMode);
      scheduleRenderSceneList();
    });

    folderFilter.addEventListener("change", () => {
      folderFilterId = folderFilter.value;
      localStorage.setItem(LS_UI_FOLDER_FILTER, folderFilterId);

      // çµã‚Šè¾¼ã¿ã«å…¥ã£ãŸã‚‰ã€ãƒ•ã‚©ãƒ«ãƒ€é™å®šæ¤œç´¢ã¯æ„å‘³ãŒé‡è¤‡ã™ã‚‹ã®ã§è§£é™¤ï¼ˆæ··ä¹±é˜²æ­¢ï¼‰
      if (folderFilterId !== "ALL"){
        setSearchScope("");
      }

      if (folderFilterId !== "ALL"){
        newSceneFolderId = folderFilterId;
        localStorage.setItem(LS_UI_NEW_SCENE_FOLDER, newSceneFolderId);
      }

      scheduleRenderSceneList();
    });

    folderManage.addEventListener("click", openFolderDialog);
    folderDialogCloseBtn.addEventListener("click", closeFolderDialog);
    folderNewBtn.addEventListener("click", createFolder);

    folderCollapseAllBtn.addEventListener("click", () => {
      if (!(isFolderChunkMode() && search.value.trim() === "")) return;
      setAllFoldersCollapsed(true);
      scheduleRenderSceneList();
      showToast("å…¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’æŠ˜ã‚ŠãŸãŸã¿ã¾ã—ãŸ");
    });
    folderExpandAllBtn.addEventListener("click", () => {
      if (!(isFolderChunkMode() && search.value.trim() === "")) return;
      setAllFoldersCollapsed(false);
      scheduleRenderSceneList();
      showToast("å…¨ãƒ•ã‚©ãƒ«ãƒ€ã‚’å±•é–‹ã—ã¾ã—ãŸ");
    });

    window.addEventListener("resize", () => {
      applyLibraryLayout();
      if (isMobile()) setLibraryOpen(false);
    });

    function closeDrawerIfCollapsed(){
      if (document.body.classList.contains("lib-collapsed")) setLibraryOpen(false);
    }

    // =========================
    // Scene editor: bind/load/save
    // =========================
    function bindSceneEditorTo(id){
      boundSceneId = id;
      scene.dataset.boundSceneId = (id ?? "");
    }

    function loadSceneText(db, id){
      if (id === null){
        const draft = getSceneDraftRaw(null);
        return (draft !== null) ? draft : "";
      }
      const draft = getSceneDraftRaw(id);
      if (draft !== null) return draft;
      const s = findSceneById(db, id);
      return s ? (s.text ?? "") : "";
    }

    function updateSceneUI(){
      const db = readSceneDB();
      const saveBtn = $("sceneSave");
      const saveAsBtn = $("sceneSaveAs");

      renderSceneFolderSelect();

      if (currentSceneId === null){
        currentSceneNameBadge.textContent = "æ–°è¦";
        const hasText = (scene.value ?? "").length > 0;
        sceneDirtyBadge.style.display = hasText ? "inline-flex" : "none";
        $("sceneRevert").style.display = "none";
        deleteSceneBtn.disabled = true;

        saveBtn.textContent = "ä¿å­˜";
        saveAsBtn.textContent = "åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜";

        sceneFavBtn.disabled = true;
        sceneFavBtn.textContent = "â˜†";
        sceneFavBtn.classList.remove("active");
        return;
      }

      const s = findSceneById(db, currentSceneId);
      currentSceneNameBadge.textContent = s?.name ?? "ï¼ˆä¸æ˜ï¼‰";

      const saved = s?.text ?? "";
      const dirty = (scene.value ?? "") !== saved;

      sceneDirtyBadge.style.display = dirty ? "inline-flex" : "none";
      $("sceneRevert").style.display = dirty ? "inline-flex" : "none";
      deleteSceneBtn.disabled = false;

      saveBtn.textContent = dirty ? "æ›´æ–°" : "ä¿å­˜";
      saveAsBtn.textContent = "è¤‡è£½ã—ã¦ä¿å­˜";

      sceneFavBtn.disabled = false;
      const isFav = !!s?.fav;
      sceneFavBtn.textContent = isFav ? "â˜…" : "â˜†";
      sceneFavBtn.classList.toggle("active", isFav);
      sceneFavBtn.title = isFav ? "ãŠæ°—ã«å…¥ã‚Šè§£é™¤" : "ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ";
    }

    function commitSceneDraftForBound(){
      const id = boundSceneId;
      setSceneDraft(id, scene.value ?? "");
    }

    function selectSceneById(id){
      if (switchingScene) return;

      commitSceneDraftForBound();

      switchingScene = true;
      switchingFromSceneId = boundSceneId;

      const db = readSceneDB();
      currentSceneId = id;
      localStorage.setItem(LS_SCENE_SELECTED_ID, id);

      expandFolderForSceneId(id);
      scrollToActiveNext = true;

      scene.value = loadSceneText(db, id);

      requestAnimationFrame(() => {
        bindSceneEditorTo(id);
        switchingScene = false;
        switchingFromSceneId = null;
        updateSceneUI();
        scheduleRenderSceneList();
        closeDrawerIfCollapsed();
        showToast("ã‚·ãƒ¼ãƒ³ã‚’å‘¼ã³å‡ºã—ã¾ã—ãŸ");
      });
    }

    function newScene(){
      if (switchingScene) return;

      commitSceneDraftForBound();

      switchingScene = true;
      switchingFromSceneId = boundSceneId;

      currentSceneId = null;
      localStorage.setItem(LS_SCENE_SELECTED_ID, "");

      const db = readSceneDB();
      scene.value = loadSceneText(db, null);

      requestAnimationFrame(() => {
        bindSceneEditorTo(null);
        switchingScene = false;
        switchingFromSceneId = null;
        updateSceneUI();
        scheduleRenderSceneList();
        closeDrawerIfCollapsed();

        if (nextNewSceneToast){
          showToast(nextNewSceneToast);
          nextNewSceneToast = "";
        } else {
          showToast("æ–°è¦ã‚·ãƒ¼ãƒ³");
        }
      });
    }

    function saveScene(){
      if (switchingScene) { showToast("åˆ‡æ›¿ä¸­ã®ãŸã‚å°‘ã—å¾…ã£ã¦ãã ã•ã„"); return; }

      const db = readSceneDB();

      if (currentSceneId === null){
        saveSceneAs();
        return;
      }

      const s = findSceneById(db, currentSceneId);
      if (!s){ showToast("ä¿å­˜å¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return; }

      const nextText = scene.value ?? "";
      const prevText = s.text ?? "";

      if (nextText === prevText){
        clearSceneDraft(currentSceneId);
        updateSceneUI();
        scheduleRenderSceneList();
        showToast("å¤‰æ›´ãªã—");
        return;
      }

      s.text = nextText;
      s.updatedAt = nowISO();

      writeSceneDB(db);
      clearSceneDraft(currentSceneId);

      updateSceneUI();
      scheduleRenderSceneList();
      showToast("æ›´æ–°ã—ã¾ã—ãŸ");
    }

    function saveSceneAs(){
      if (switchingScene) { showToast("åˆ‡æ›¿ä¸­ã®ãŸã‚å°‘ã—å¾…ã£ã¦ãã ã•ã„"); return; }

      const db = readSceneDB();
      const existingNames = new Set(db.scenes.map(s => s.name));

      const suggestion =
        (currentSceneId !== null)
          ? (findSceneById(db, currentSceneId)?.name ?? "")
          : "";

      const name0 = (prompt("ä¿å­˜åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã‚·ãƒ¼ãƒ³ï¼‰", suggestion) ?? "").trim();
      if (!name0){ showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«"); return; }

      const finalName = uniqueName(existingNames, name0, "scene");

      const fset = folderSet();
      const chosenFolderId = safeFolderId(sceneFolderSelect.value, fset);

      const newObj = normalizeSceneObj({
        id: uuid(),
        name: finalName,
        text: scene.value ?? "",
        createdAt: nowISO(),
        updatedAt: nowISO(),
        fav: false,
        folderId: chosenFolderId,
        order: NaN
      });

      const afterId =
        (currentSceneId !== null && (findSceneById(db, currentSceneId)?.folderId ?? "") === chosenFolderId)
          ? currentSceneId
          : null;

      insertNewSceneIntoFolder(db, newObj, afterId);

      writeSceneDB(db);
      clearSceneDraft(null);

      currentSceneId = newObj.id;
      localStorage.setItem(LS_SCENE_SELECTED_ID, newObj.id);
      bindSceneEditorTo(newObj.id);

      expandFolderForSceneId(newObj.id);
      scrollToActiveNext = true;

      updateSceneUI();
      scheduleRenderSceneList();

      showToast(finalName !== name0 ? `ã€Œ${finalName}ã€ã¨ã—ã¦è¤‡è£½ã—ã¾ã—ãŸ` : "åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜ã—ã¾ã—ãŸ");
    }

    function revertScene(){
      const db = readSceneDB();
      if (currentSceneId === null) return;
      const s = findSceneById(db, currentSceneId);
      if (!s) return;

      scene.value = s.text ?? "";
      clearSceneDraft(currentSceneId);
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("ä¿å­˜æ¸ˆã¿ã«æˆ»ã—ã¾ã—ãŸ");
    }

    function deleteScene(){
      const db = readSceneDB();
      if (currentSceneId === null) return;
      const s = findSceneById(db, currentSceneId);
      if (!s) return;

      const ok = confirm(`ã€Œ${s.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰`);
      if (!ok) return;

      const fset = folderSet();
      const fid = safeFolderId(s.folderId, fset);

      db.scenes = db.scenes.filter(x => x.id !== currentSceneId);
      writeSceneDB(db);
      clearSceneDraft(currentSceneId);

      const remaining = db.scenes
        .filter(x => safeFolderId(x.folderId, fset) === fid)
        .sort((a,b)=> (Number.isFinite(a.order)?a.order:1e18) - (Number.isFinite(b.order)?b.order:1e18));
      let ord = 10;
      for (const x of remaining){ x.order = ord; ord += 10; }
      writeSceneDB(db);

      currentSceneId = null;
      localStorage.setItem(LS_SCENE_SELECTED_ID, "");
      bindSceneEditorTo(null);

      scene.value = loadSceneText(db, null);
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("å‰Šé™¤ã—ã¾ã—ãŸ");
    }

    scene.addEventListener("input", () => {
      const targetId = switchingScene ? switchingFromSceneId : boundSceneId;
      setSceneDraft(targetId, scene.value ?? "");
      updateSceneUI();
      scheduleRenderSceneList();
    });

    sceneFavBtn.addEventListener("click", () => {
      if (currentSceneId === null) return;
      toggleSceneFavorite(currentSceneId);
    });

    sceneFolderSelect.addEventListener("change", () => {
      const fset = folderSet();
      const fid = safeFolderId(sceneFolderSelect.value, fset);

      if (currentSceneId === null){
        newSceneFolderId = fid;
        localStorage.setItem(LS_UI_NEW_SCENE_FOLDER, newSceneFolderId);
        showToast("æ–°è¦ã®ä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€ã‚’å¤‰æ›´");
        return;
      }

      moveSceneToFolder(currentSceneId, fid);
    });

    // =========================
    // Fixed presets
    // =========================
    function readFixedLib(){
      try{
        const raw = localStorage.getItem(LS_FIXED_LIB);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === "object") ? obj : {};
      } catch { return {}; }
    }
    function writeFixedLib(lib){
      localStorage.setItem(LS_FIXED_LIB, JSON.stringify(lib));
    }
    function fixedDraftKey(name){
      return LS_FIXED_DRAFT_PREFIX + encodeURIComponent(name);
    }
    function getFixedDraftRaw(name){
      return localStorage.getItem(fixedDraftKey(name));
    }
    function setFixedDraft(name, text){
      localStorage.setItem(fixedDraftKey(name), text ?? "");
    }
    function clearFixedDraft(name){
      localStorage.removeItem(fixedDraftKey(name));
    }
    function sortedFixedNames(lib){
      return Object.keys(lib).sort((a,b)=>{
        const ua = lib[a]?.updatedAt ?? "";
        const ub = lib[b]?.updatedAt ?? "";
        if (ua !== ub) return ua < ub ? 1 : -1;
        return a.localeCompare(b, "ja");
      });
    }
    function ensureFixedDefault(){
      const lib = readFixedLib();
      if (Object.keys(lib).length > 0) return;

      const old = localStorage.getItem(LS_OLD_FIXED_SINGLE) ?? "";
      lib["ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ"] = { text: old, updatedAt: nowISO() };
      writeFixedLib(lib);
      localStorage.setItem(LS_FIXED_SELECTED, "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ");
    }
    function renderFixedSelect(){
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);

      fixedSelect.innerHTML = "";
      for (const n of names){
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        fixedSelect.appendChild(opt);
      }

      if (!names.includes(currentFixedName)){
        currentFixedName = names[0] || "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ";
      }
      fixedSelect.value = currentFixedName;
      updateFixedUI();
    }
    function bindFixedEditorTo(name){
      boundFixedName = name;
      fixed.dataset.boundFixedName = name;
    }
    function loadFixedText(name){
      const lib = readFixedLib();
      const draft = getFixedDraftRaw(name);
      if (draft !== null) return draft;
      return String(lib[name]?.text ?? "");
    }
    function updateFixedUI(){
      const lib = readFixedLib();
      const saved = String(lib[currentFixedName]?.text ?? "");
      const dirty = (fixed.value ?? "") !== saved;

      fixedCurrentNameBadge.textContent = currentFixedName || "â€”";
      fixedDirtyBadge.style.display = dirty ? "inline-flex" : "none";
      $("fixedRevert").style.display = dirty ? "inline-flex" : "none";

      $("fixedSave").textContent = dirty ? "æ›´æ–°" : "ä¿å­˜";
      $("fixedSaveAs").textContent = "è¤‡è£½ã—ã¦ä¿å­˜";

      const count = Object.keys(lib).length;
      fixedDeleteBtn.disabled = (count <= 1);
    }
    function commitFixedDraftForBound(){
      if (!boundFixedName) return;
      setFixedDraft(boundFixedName, fixed.value ?? "");
    }
    function selectFixed(name){
      if (!name || switchingFixed) return;

      commitFixedDraftForBound();
      switchingFixed = true;
      switchingFromFixedName = boundFixedName;

      currentFixedName = name;
      localStorage.setItem(LS_FIXED_SELECTED, name);

      fixed.value = loadFixedText(name);

      requestAnimationFrame(() => {
        bindFixedEditorTo(name);
        switchingFixed = false;
        switchingFromFixedName = "";
        renderFixedSelect();
        showToast("å›ºå®šãƒ—ãƒªã‚»ãƒƒãƒˆã‚’åˆ‡æ›¿");
      });
    }
    function saveFixed(){
      const lib = readFixedLib();
      const prev = String(lib[currentFixedName]?.text ?? "");
      const next = fixed.value ?? "";

      if (next === prev){
        clearFixedDraft(currentFixedName);
        updateFixedUI();
        showToast("å¤‰æ›´ãªã—");
        return;
      }

      lib[currentFixedName] = { text: next, updatedAt: nowISO() };
      writeFixedLib(lib);
      clearFixedDraft(currentFixedName);
      updateFixedUI();
      renderFixedSelect();
      showToast("æ›´æ–°ã—ã¾ã—ãŸ");
    }
    function saveFixedAs(){
      const lib = readFixedLib();
      const suggestion = currentFixedName || "";

      const name0 = (prompt("ä¿å­˜åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆå›ºå®šï¼‰", suggestion) ?? "").trim();
      if (!name0){ showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«"); return; }

      const existingNames = new Set(Object.keys(lib));
      const finalName = uniqueName(existingNames, name0, "å›ºå®š");

      lib[finalName] = { text: fixed.value ?? "", updatedAt: nowISO() };
      writeFixedLib(lib);

      currentFixedName = finalName;
      localStorage.setItem(LS_FIXED_SELECTED, finalName);
      clearFixedDraft(finalName);

      renderFixedSelect();
      updateFixedUI();
      showToast(finalName !== name0 ? `ã€Œ${finalName}ã€ã¨ã—ã¦è¤‡è£½ã—ã¾ã—ãŸ` : "è¤‡è£½ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ");
    }
    function revertFixed(){
      const lib = readFixedLib();
      fixed.value = String(lib[currentFixedName]?.text ?? "");
      clearFixedDraft(currentFixedName);
      updateFixedUI();
      showToast("ä¿å­˜æ¸ˆã¿ã«æˆ»ã—ã¾ã—ãŸ");
    }
    function deleteFixed(){
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);
      if (names.length <= 1){ showToast("æœ€å¾Œã®1ä»¶ã¯å‰Šé™¤ã§ãã¾ã›ã‚“"); return; }

      const ok = confirm(`ã€Œ${currentFixedName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰`);
      if (!ok) return;

      delete lib[currentFixedName];
      writeFixedLib(lib);
      clearFixedDraft(currentFixedName);

      const next = sortedFixedNames(lib)[0];
      currentFixedName = next;
      localStorage.setItem(LS_FIXED_SELECTED, next);
      fixed.value = loadFixedText(next);
      bindFixedEditorTo(next);

      renderFixedSelect();
      updateFixedUI();
      showToast("å›ºå®šãƒ—ãƒªã‚»ãƒƒãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ");
    }

    fixed.addEventListener("input", () => {
      const target = switchingFixed ? switchingFromFixedName : boundFixedName;
      if (!target) return;
      setFixedDraft(target, fixed.value ?? "");
      updateFixedUI();
    });

    // =========================
    // Output actions
    // =========================
    function refreshOutput(){
      lastMerged = merge();
      output.value = lastMerged;
    }

    async function doMergeCopy(){
      refreshOutput();
      if (!lastMerged){ showToast("ç©ºã§ã™"); return; }
      const ok = await copyToClipboard(lastMerged);
      showToast(ok ? "åˆä½“ã—ã¦ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ" : "ã‚³ãƒ”ãƒ¼å¤±æ•—ï¼šå‡ºåŠ›æ¬„ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„");
      if (!ok) outputDetails.open = true;
    }

    // =========================
    // Export / Import
    // =========================
    $("exportJson").addEventListener("click", () => {
      const data = {
        version: 8,
        exportedAt: nowISO(),
        foldersDB: { version: 2, folders: readFolderDB().folders },
        scenesDB: { version: 2, scenes: readSceneDB().scenes },
        fixedPresets: readFixedLib()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `prompt_tool_backup_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ");
    });

    $("importJson").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try{
        const text = await file.text();
        const obj = JSON.parse(text);

        if (obj?.foldersDB?.folders && Array.isArray(obj.foldersDB.folders)){
          const cur = readFolderDB();
          const existingIds = new Set(cur.folders.map(f=>f.id));
          const existingNames = new Set(cur.folders.map(f=>f.name));

          for (const f of obj.foldersDB.folders){
            const id0 = String(f?.id ?? "");
            const name0 = String(f?.name ?? "").trim();
            if (!name0) continue;
            if (id0 === FOLDER_UNFILED_ID) continue;

            const id = (id0 && !existingIds.has(id0)) ? id0 : uuid();
            const name = existingNames.has(name0) ? uniqueName(existingNames, name0, "ãƒ•ã‚©ãƒ«ãƒ€") : name0;

            existingIds.add(id);
            existingNames.add(name);

            cur.folders.push({
              id,
              name,
              createdAt: f?.createdAt ?? nowISO(),
              updatedAt: f?.updatedAt ?? nowISO(),
              order: asNum(f?.order)
            });
          }

          if (!cur.folders.some(f => f.id === FOLDER_UNFILED_ID)){
            cur.folders.unshift({ id: FOLDER_UNFILED_ID, name: "æœªåˆ†é¡", createdAt: nowISO(), updatedAt: nowISO(), order: 0 });
          }
          writeFolderDB(cur);
          repairFolderOrders();
        }

        if (obj?.scenesDB?.scenes && Array.isArray(obj.scenesDB.scenes)){
          const db = readSceneDB();
          const existingIds = new Set(db.scenes.map(s=>s.id));
          const existingNames = new Set(db.scenes.map(s=>s.name));
          const fset = folderSet();

          for (const s of obj.scenesDB.scenes){
            const id0 = String(s?.id ?? "");
            const name0 = String(s?.name ?? "scene");
            const id = (id0 && !existingIds.has(id0)) ? id0 : uuid();
            const name = existingNames.has(name0) ? uniqueName(existingNames, name0, "scene") : name0;

            existingIds.add(id);
            existingNames.add(name);

            db.scenes.push(normalizeSceneObj({
              id,
              name,
              text: String(s?.text ?? ""),
              createdAt: String(s?.createdAt ?? nowISO()),
              updatedAt: String(s?.updatedAt ?? nowISO()),
              fav: !!s?.fav,
              folderId: safeFolderId(String(s?.folderId ?? FOLDER_UNFILED_ID), fset),
              order: asNum(s?.order)
            }));
          }

          writeSceneDB(db);
          repairSceneFolderAndOrders();
        }

        if (obj?.fixedPresets && typeof obj.fixedPresets === "object"){
          const lib = readFixedLib();
          for (const [name, payload] of Object.entries(obj.fixedPresets)){
            const existingNames = new Set(Object.keys(lib));
            const finalName = existingNames.has(name) ? uniqueName(existingNames, name, "å›ºå®š") : name;
            lib[finalName] = { text: String(payload?.text ?? ""), updatedAt: payload?.updatedAt ?? nowISO() };
          }
          writeFixedLib(lib);
        }

        init();
        showToast("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ");
      } catch {
        showToast("ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—ï¼ˆJSONå½¢å¼ã‚’ç¢ºèªï¼‰");
      } finally {
        e.target.value = "";
      }
    });

    // =========================
    // Wiring
    // =========================
    $("mergeCopy").addEventListener("click", doMergeCopy);
    $("mergeCopy2").addEventListener("click", doMergeCopy);

    $("copyOnly").addEventListener("click", async () => {
      if (!output.value) refreshOutput();
      if (!output.value){ showToast("ç©ºã§ã™"); return; }
      const ok = await copyToClipboard(output.value);
      showToast(ok ? "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ" : "ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ");
    });

    $("showOutput").addEventListener("click", () => {
      refreshOutput();
      outputDetails.open = true;
      output.focus();
    });

    $("refreshOutput").addEventListener("click", () => {
      refreshOutput();
      showToast("æ›´æ–°ã—ã¾ã—ãŸ");
    });

    $("copyOutput").addEventListener("click", async () => {
      if (!output.value) refreshOutput();
      if (!output.value){ showToast("ç©ºã§ã™"); return; }
      outputDetails.open = true;
      output.focus();
      output.select();
      const ok = await copyToClipboard(output.value);
      showToast(ok ? "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ" : "ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ");
    });

    $("newScene").addEventListener("click", () => {
      nextNewSceneToast = "";
      newScene();
    });

    $("deleteScene").addEventListener("click", deleteScene);
    $("sceneSave").addEventListener("click", saveScene);
    $("sceneSaveAs").addEventListener("click", saveSceneAs);
    $("sceneRevert").addEventListener("click", revertScene);
    $("sceneClear").addEventListener("click", () => {
      scene.value = "";
      setSceneDraft(boundSceneId, "");
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("ã‚·ãƒ¼ãƒ³å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢");
    });

    search.addEventListener("input", () => {
      // é™å®šæ¤œç´¢ä¸­ã¯ã€Œè¦‹ãˆãªã„ã€äº‹æ•…ã‚’æ¸›ã‚‰ã™ãŸã‚ã€å¯¾è±¡ãƒ•ã‚©ãƒ«ãƒ€ã‚’å±•é–‹
      if (search.value.trim() !== "" && hasSearchScope() && folderCollapseMap[searchScopeFolderId]){
        delete folderCollapseMap[searchScopeFolderId];
        saveFolderCollapseMap();
      }
      scheduleRenderSceneList();
    });

    clearSearchBtn.addEventListener("click", () => {
      if (!search.value) return;
      search.value = "";
      scheduleRenderSceneList();
      search.focus();
      showToast("æ¤œç´¢ã‚’ã‚¯ãƒªã‚¢");
    });

    searchScopeBadge.addEventListener("click", () => {
      if (!hasSearchScope()) return;
      setSearchScope("");
      scheduleRenderSceneList();
      search.focus();
      search.select();
      showToast("æ¤œç´¢ã®é™å®šã‚’è§£é™¤");
    });

    fixedSelect.addEventListener("change", () => selectFixed(fixedSelect.value));
    $("openFixed").addEventListener("click", () => { fixedDetails.open = true; fixed.focus(); });

    $("fixedSave").addEventListener("click", saveFixed);
    $("fixedSaveAs").addEventListener("click", saveFixedAs);
    $("fixedRevert").addEventListener("click", revertFixed);
    $("fixedClear").addEventListener("click", () => {
      fixed.value = "";
      setFixedDraft(currentFixedName, "");
      updateFixedUI();
      showToast("å›ºå®šå…¥åŠ›ã‚’ã‚¯ãƒªã‚¢");
    });
    $("fixedDelete").addEventListener("click", deleteFixed);

    dividerPreset.addEventListener("change", () => {
      dividerCustom.style.display = dividerPreset.value === "CUSTOM" ? "block" : "none";
    });

    // Ctrl shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && (e.key === "k" || e.key === "K")){
        e.preventDefault();
        if (document.body.classList.contains("lib-collapsed")) setLibraryOpen(true);
        search.focus();
        search.select();
        return;
      }
      if (e.ctrlKey && e.key === "Enter"){
        e.preventDefault();
        doMergeCopy();
        return;
      }
      if (e.ctrlKey && (e.key === "s" || e.key === "S")){
        e.preventDefault();
        const inFixed = (document.activeElement === fixed);
        if (e.shiftKey){
          if (inFixed) saveFixedAs();
          else saveSceneAs();
        } else {
          if (inFixed) saveFixed();
          else saveScene();
        }
        return;
      }
      if (e.key === "Escape"){
        if (document.activeElement === search && search.value.trim() !== ""){
          e.preventDefault();
          search.value = "";
          scheduleRenderSceneList();
          showToast("æ¤œç´¢ã‚’ã‚¯ãƒªã‚¢");
          return;
        }
        if (document.body.classList.contains("lib-collapsed") && document.body.classList.contains("lib-open")){
          e.preventDefault();
          setLibraryOpen(false);
          return;
        }
      }
    });

    // =========================
    // Init
    // =========================
    function init(){
      dividerPreset.value = "\n\n";
      dividerCustom.value = "";
      dividerCustom.style.display = "none";
      trim.checked = true;

      ensureDefaultFolders();
      repairFolderOrders();

      migrateVeryOldScenesIfNeeded();
      repairSceneFolderAndOrders();

      folderCollapseMap = loadFolderCollapseMap();
      sanitizeFolderCollapseMap();

      sanitizeSearchScope();

      applyLibraryLayout();

      const db = readSceneDB();
      const sel = localStorage.getItem(LS_SCENE_SELECTED_ID) ?? "";
      if (sel && findSceneById(db, sel)){
        currentSceneId = sel;
        expandFolderForSceneId(sel);
      } else {
        currentSceneId = null;
      }

      scene.value = loadSceneText(db, currentSceneId);
      bindSceneEditorTo(currentSceneId);

      updateSceneUI();
      renderSceneList();

      ensureFixedDefault();
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);
      currentFixedName = localStorage.getItem(LS_FIXED_SELECTED) ?? names[0];
      if (!lib[currentFixedName]) currentFixedName = names[0];
      localStorage.setItem(LS_FIXED_SELECTED, currentFixedName);

      fixed.value = loadFixedText(currentFixedName);
      bindFixedEditorTo(currentFixedName);
      renderFixedSelect();
      updateFixedUI();

      refreshOutput();
    }

    init();
  </script>
</body>
</html>
