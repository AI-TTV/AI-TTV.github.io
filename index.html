<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>プロンプト合体</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#5b6474;
      --line:#e6e8f0;
      --primary:#2563eb;
      --primary2:#1d4ed8;
      --danger:#dc2626;
      --ok:#16a34a;
      --shadow: 0 10px 24px rgba(15, 23, 42, .08);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b1020;
        --panel:#0f1630;
        --text:#eaf0ff;
        --muted:#a7b1c7;
        --line:#223055;
        --primary:#6aa7ff;
        --primary2:#3f8cff;
        --danger:#ff4d6d;
        --ok:#2bd576;
        --shadow: 0 14px 30px rgba(0,0,0,.35);
      }
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap{ max-width: 1180px; margin: 18px auto 42px; padding: 0 14px; }

    header{
      display:flex; align-items:flex-end; justify-content:space-between; gap:14px;
      margin-bottom: 12px;
    }
    h1{ font-size: 18px; margin:0; letter-spacing:.2px; }
    .sub{
      margin-top:6px;
      font-size: 12px; color: var(--muted);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      border-radius:999px;
      padding: 4px 10px;
      background: rgba(255,255,255,.45);
    }
    @media (prefers-color-scheme: dark){
      .chip{ background: rgba(0,0,0,.18); }
    }
    .chipSelect select{
      width: 240px;
      padding: 6px 8px;
      border-radius: 10px;
      border:1px solid var(--line);
      background: transparent;
      color: var(--text);
      font-size: 12px;
      outline:none;
    }

    .layout{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      header{ flex-direction:column; align-items:flex-start; }
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHead{
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .panelTitle{
      font-weight: 900; font-size: 13px;
      display:flex; align-items:center; gap:8px;
    }
    .panelBody{ padding: 12px; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row + .row{ margin-top: 10px; }
    .grow{ flex:1; min-width: 180px; }

    input[type="text"], select, textarea{
      width:100%;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.65);
      color: var(--text);
      padding: 10px 12px;
      outline:none;
      font-size: 13px;
    }
    @media (prefers-color-scheme: dark){
      input[type="text"], select, textarea{ background: rgba(0,0,0,.18); }
    }
    textarea{
      font-family: var(--mono);
      min-height: 320px;
      resize: vertical;
      line-height: 1.5;
    }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,.55);
      cursor:pointer;
      font-weight: 900;
      font-size: 13px;
      user-select:none;
      color: var(--text);
    }
    @media (prefers-color-scheme: dark){
      .btn{ background: rgba(255,255,255,.06); }
    }
    .btn.primary{
      background: linear-gradient(180deg, var(--primary), var(--primary2));
      border-color: rgba(0,0,0,.0);
      color: #fff;
    }
    .btn.ok{
      background: linear-gradient(180deg, rgba(22,163,74,.95), rgba(22,163,74,.82));
      border-color: rgba(0,0,0,.0);
      color:#fff;
    }
    .btn.danger{
      background: linear-gradient(180deg, var(--danger), rgba(220,38,38,.86));
      border-color: rgba(0,0,0,.0);
      color:#fff;
    }
    @media (prefers-color-scheme: dark){
      .btn.danger{ background: linear-gradient(180deg, var(--danger), rgba(255,77,109,.78)); }
      .btn.ok{ background: linear-gradient(180deg, var(--ok), rgba(43,213,118,.78)); color:#07120b; }
    }
    .btn.small{ padding: 8px 10px; border-radius: 10px; font-size: 12px; }

    .hint{ font-size: 12px; color: var(--muted); line-height: 1.5; margin-top: 8px; }

    .list{
      display:flex; flex-direction:column;
      gap: 6px;
      max-height: 520px;
      overflow:auto;
      padding-right: 2px;
    }
    .sceneItem{
      width:100%;
      text-align:left;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(255,255,255,.55);
      padding: 10px 10px;
      cursor:pointer;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    @media (prefers-color-scheme: dark){
      .sceneItem{ background: rgba(255,255,255,.06); }
    }
    .sceneItem.active{
      border-color: rgba(37,99,235,.55);
      box-shadow: 0 0 0 3px rgba(37,99,235,.10);
    }
    @media (prefers-color-scheme: dark){
      .sceneItem.active{
        border-color: rgba(106,167,255,.65);
        box-shadow: 0 0 0 3px rgba(106,167,255,.16);
      }
    }
    .sceneName{ font-weight: 900; font-size: 13px; }
    .sceneMeta{ font-size: 11px; color: var(--muted); margin-top: 4px; }
    .dot{
      width:10px; height:10px; border-radius:999px; margin-top: 4px;
      border:1px solid var(--line);
      background: transparent;
      flex:none;
    }
    .dot.draft{ background: rgba(234,179,8,.95); border-color: rgba(234,179,8,.25); }
    @media (prefers-color-scheme: dark){
      .dot.draft{ background: rgba(250,204,21,.95); }
    }

    details{
      margin-top: 12px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    summary{
      cursor:pointer;
      list-style:none;
      padding: 10px 12px;
      font-weight: 900;
      font-size: 13px;
      display:flex; align-items:center; justify-content:space-between;
    }
    summary::-webkit-details-marker{ display:none; }
    .detailsBody{ padding: 12px; border-top:1px solid var(--line); }

    .dangerZone{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(220,38,38,.35);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    .statusLine{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      font-size: 12px; color: var(--muted);
    }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.45);
      color: var(--muted);
    }
    @media (prefers-color-scheme: dark){
      .badge{ background: rgba(0,0,0,.18); }
    }
    .badge.warn{ color: #7c5a00; border-color: rgba(234,179,8,.35); }
    @media (prefers-color-scheme: dark){
      .badge.warn{ color: #ffe08a; }
    }

    .toast{
      position: fixed; right: 16px; bottom: 16px;
      background: rgba(15, 23, 42, .92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
      opacity: 0;
      transform: translateY(8px);
      transition: .18s ease;
      pointer-events:none;
    }
    .toast.show{ opacity: 1; transform: translateY(0); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>プロンプト合体</h1>
        <div class="sub">
          <span class="chip">Ctrl+Enter：合体してコピー</span>
          <span class="chip">Ctrl+S：保存/更新（フォーカスでシーン/固定を判定）</span>
          <span class="chip">Ctrl+Shift+S：名前付き保存/複製</span>

          <span class="chip chipSelect">
            固定プリセット：
            <select id="fixedSelect"></select>
          </span>

          <button class="btn small" id="openFixed">固定を編集</button>
        </div>
      </div>

      <div class="row">
        <button class="btn primary" id="mergeCopy">合体してコピー</button>
        <button class="btn" id="copyOnly">出力だけコピー</button>
      </div>
    </header>

    <div class="layout">
      <!-- Left: Scene Library -->
      <section class="panel">
        <div class="panelHead">
          <div class="panelTitle">シーン一覧</div>
          <div class="statusLine">
            <span class="badge" id="sceneCount">0件</span>
          </div>
        </div>
        <div class="panelBody">
          <div class="row">
            <input id="search" type="text" class="grow" placeholder="検索（名前）" />
            <button class="btn small" id="newScene">新規</button>
          </div>

          <div class="hint" style="margin-top:6px;">
            保存対象は<strong>ID固定</strong>。並び替えで位置が変わっても別シーンに上書きされません。
          </div>

          <div class="list" id="sceneList" style="margin-top:10px;"></div>

          <div class="dangerZone">
            <button class="btn danger" id="deleteScene" disabled>選択中を削除</button>
            <span class="hint" style="margin:0;">※ 削除は確認が出ます</span>
          </div>
        </div>
      </section>

      <!-- Right: Scene Editor -->
      <section class="panel">
        <div class="panelHead">
          <div class="panelTitle">編集</div>
          <div class="statusLine">
            <span class="badge" id="currentSceneName">新規</span>
            <span class="badge warn" id="sceneDirtyBadge" style="display:none;">未保存（下書き）</span>
          </div>
        </div>
        <div class="panelBody">
          <div class="row">
            <button class="btn ok" id="sceneSave">保存</button>
            <button class="btn" id="sceneSaveAs">名前を付けて保存</button>
            <button class="btn" id="sceneRevert" style="display:none;">保存済みに戻す</button>
            <button class="btn" id="sceneClear">シーン入力をクリア</button>
          </div>

          <textarea id="scene" placeholder="シーンプロンプト（編集対象）"></textarea>

          <div class="row" style="margin-top:10px;">
            <button class="btn primary" id="mergeCopy2" style="flex:1;">合体してコピー</button>
            <button class="btn" id="showOutput">合体結果を開く</button>
          </div>

          <div class="hint">
            既存を編集したら「更新」。既存を別名で残すなら「複製して保存」。
          </div>
        </div>
      </section>
    </div>

    <!-- Output -->
    <details id="outputDetails">
      <summary>合体結果（確認・手動コピー用）</summary>
      <div class="detailsBody">
        <div class="row">
          <button class="btn" id="refreshOutput">合体結果を更新</button>
          <button class="btn" id="copyOutput">この欄をコピー</button>
        </div>
        <textarea id="output" style="min-height:220px; margin-top:10px;" placeholder="合体結果がここに表示されます"></textarea>
        <div class="hint">※ 自動コピーが失敗する場合は、この欄を開いて Ctrl+C でコピーできます。</div>
      </div>
    </details>

    <!-- Fixed -->
    <details id="fixedDetails">
      <summary>固定プロンプト（プリセット対応 / 普段は閉じてOK）</summary>
      <div class="detailsBody">
        <div class="row">
          <div class="statusLine">
            <span class="badge" id="fixedCurrentName">—</span>
            <span class="badge warn" id="fixedDirtyBadge" style="display:none;">未保存（下書き）</span>
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <button class="btn ok" id="fixedSave">保存</button>
          <button class="btn" id="fixedSaveAs">複製して保存</button>
          <button class="btn" id="fixedRevert" style="display:none;">保存済みに戻す</button>
          <button class="btn" id="fixedClear">固定入力をクリア</button>
        </div>

        <textarea id="fixed" style="min-height:220px; margin-top:10px;" placeholder="固定プロンプト"></textarea>

        <div class="dangerZone">
          <button class="btn danger" id="fixedDelete">この固定プリセットを削除</button>
          <span class="hint" style="margin:0;">※ 最後の1件は削除できません</span>
        </div>

        <div class="hint">固定も：編集したら「更新」、別名で残すなら「複製して保存」。</div>
      </div>
    </details>

    <!-- Options -->
    <details id="optionsDetails">
      <summary>詳細設定（必要なときだけ）</summary>
      <div class="detailsBody">
        <div class="row">
          <label style="min-width:88px; margin:0; color:var(--muted); font-size:12px;">区切り</label>
          <select id="dividerPreset" class="grow">
            <option value="\n\n" selected>空行（デフォルト）</option>
            <option value="\n\n---\n\n">---</option>
            <option value="\n\n================\n\n">====</option>
            <option value="CUSTOM">カスタム</option>
          </select>
          <input id="dividerCustom" type="text" class="grow" placeholder="カスタム区切り（例：\n\n[SCENE]\n\n）" style="display:none;" />
        </div>

        <div class="row">
          <label class="row" style="gap:8px; color:var(--muted); font-size:12px;">
            <input type="checkbox" id="trim" checked />
            空白を整理して合体する（先頭は保持・行末のスペース/タブのみ）
          </label>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="exportJson">エクスポート（シーン＋固定 / JSON）</button>
          <label class="btn" for="importJson" style="cursor:pointer;">インポート</label>
          <input id="importJson" type="file" accept="application/json" style="display:none;" />
          <span class="hint" style="margin:0;">※ PC移行・バックアップ用</span>
        </div>
      </div>
    </details>

  </div>

  <div id="toast" class="toast">コピーしました</div>

  <script>
    const $ = (id) => document.getElementById(id);

    // ---- DOM ----
    const search = $("search");
    const sceneList = $("sceneList");
    const sceneCount = $("sceneCount");
    const deleteSceneBtn = $("deleteScene");

    const currentSceneNameBadge = $("currentSceneName");
    const sceneDirtyBadge = $("sceneDirtyBadge");

    const scene = $("scene");
    const fixed = $("fixed");
    const output = $("output");

    const fixedSelect = $("fixedSelect");
    const fixedCurrentNameBadge = $("fixedCurrentName");
    const fixedDirtyBadge = $("fixedDirtyBadge");
    const fixedDeleteBtn = $("fixedDelete");

    const fixedDetails = $("fixedDetails");
    const outputDetails = $("outputDetails");

    const dividerPreset = $("dividerPreset");
    const dividerCustom = $("dividerCustom");
    const trim = $("trim");

    const toast = $("toast");

    // ---- Keys (Scene: ID-based DB) ----
    const LS_SCENE_DB = "pm_scene_db_v1";                 // {version:1, scenes:[{id,name,text,createdAt,updatedAt}]}
    const LS_SCENE_SELECTED_ID = "pm_scene_selected_id_v1";
    const LS_SCENE_DRAFT_NEW = "pm_scene_draft_new_v1";   // draft for new
    const LS_SCENE_DRAFT_PREFIX = "pm_scene_draft_v1_";   // + id
    const LS_SCENE_MIGRATED = "pm_scene_db_v1_migrated";  // "1"

    // ---- Keys (old scene libs for migration) ----
    const OLD_SCENE_LIB_KEYS = ["pm_scene_library_v3", "pm_scene_library_v2", "pm_scene_library_v1"];
    const OLD_SELECTED_NAME_KEYS = ["pm_selected_scene_name_v3", "pm_selected_scene_name_v2", "pm_selected_scene_name_v1"];

    // ---- Keys (Fixed presets) ----
    const LS_FIXED_LIB = "pm_fixed_library_v1";            // { name: {text, updatedAt} }
    const LS_FIXED_SELECTED = "pm_selected_fixed_name_v1"; // string
    const LS_FIXED_DRAFT_PREFIX = "pm_draft_fixed_v1_";    // + encodeURIComponent(name)
    const LS_OLD_FIXED_SINGLE = "pm_fixed_v3";

    // ---- State (Scene) ----
    let currentSceneId = null;     // null => new
    let boundSceneId = null;       // what textarea is currently bound to
    let switchingScene = false;
    let switchingFromSceneId = null;

    // ---- State (Fixed) ----
    let currentFixedName = "";
    let boundFixedName = "";
    let switchingFixed = false;
    let switchingFromFixedName = "";

    // ---- Output ----
    let lastMerged = "";

    // ---- Utils ----
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 1200);
    }
    function nowISO(){ return new Date().toISOString(); }

    function uuid(){
      if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
      return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function toLF(s){ return (s ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"); }

    // 空白整理ONでも「先頭」や「行そのもの」を消さない安全版
    function normalizeForMerge(s){
      const t = toLF(s);
      if (!trim.checked) return t;
      return t
        .split("\n")
        .map(line => line.replace(/[ \t]+$/g, "")) // 行末のみ
        .join("\n");
    }

    function getDivider(){
      const v = dividerPreset.value;
      if (v === "CUSTOM") return dividerCustom.value.replaceAll("\\n", "\n");
      return v.replaceAll("\\n", "\n");
    }

    function merge(){
      const a = normalizeForMerge(fixed.value);
      const b = normalizeForMerge(scene.value);
      const d = getDivider();
      if (!a && !b) return "";
      if (!a) return b;
      if (!b) return a;
      return a + d + b;
    }

    async function copyToClipboard(text){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try{
          output.value = text;
          outputDetails.open = true;
          output.focus();
          output.select();
          return document.execCommand("copy");
        } catch {
          return false;
        }
      }
    }

    function formatUpdated(iso){
      if (!iso) return "";
      const d = new Date(iso);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const day = String(d.getDate()).padStart(2,"0");
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      return `${y}-${m}-${day} ${hh}:${mm}`;
    }

    // ★連番命名：サンプル / サンプル（2） / サンプル（3）...
    // 既に（n）や(n)で終わっていたら、その次から
    function uniqueName(existingSet, desired){
      let name = (desired ?? "").trim();
      if (!name) name = "scene";

      if (!existingSet.has(name)) return name;

      let base = name;
      let start = 2;

      const m = name.match(/^(.*?)[（(](\d+)[）)]$/);
      if (m){
        base = (m[1] ?? "").trim() || name;
        const n = parseInt(m[2], 10);
        start = Number.isFinite(n) ? Math.max(2, n + 1) : 2;
      }

      for (let i = start; i < 10000; i++){
        const cand = `${base}（${i}）`;
        if (!existingSet.has(cand)) return cand;
      }
      return `${base}（${Date.now()}）`;
    }

    // =========================
    // Scene DB (ID-based)
    // =========================
    function emptySceneDB(){ return { version: 1, scenes: [] }; }

    function readSceneDB(){
      try{
        const raw = localStorage.getItem(LS_SCENE_DB);
        if (!raw) return emptySceneDB();
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return emptySceneDB();
        if (!Array.isArray(obj.scenes)) return emptySceneDB();
        return { version: 1, scenes: obj.scenes };
      } catch {
        return emptySceneDB();
      }
    }

    function writeSceneDB(db){
      localStorage.setItem(LS_SCENE_DB, JSON.stringify({ version: 1, scenes: db.scenes }));
    }

    function sceneDraftKey(id){
      return id ? (LS_SCENE_DRAFT_PREFIX + id) : LS_SCENE_DRAFT_NEW;
    }
    function getSceneDraftRaw(id){
      return localStorage.getItem(sceneDraftKey(id)); // null or string
    }
    function setSceneDraft(id, text){
      localStorage.setItem(sceneDraftKey(id), text ?? "");
    }
    function clearSceneDraft(id){
      localStorage.removeItem(sceneDraftKey(id));
    }

    function findSceneById(db, id){
      return db.scenes.find(s => s.id === id) || null;
    }

    function migrateOldScenesIfNeeded(){
      const migrated = localStorage.getItem(LS_SCENE_MIGRATED) === "1";
      const db = readSceneDB();
      if (migrated || db.scenes.length > 0) return;

      let imported = 0;
      const existingNames = new Set();
      const newScenes = [];

      for (const key of OLD_SCENE_LIB_KEYS){
        const raw = localStorage.getItem(key);
        if (!raw) continue;
        try{
          const lib = JSON.parse(raw);
          if (!lib || typeof lib !== "object") continue;

          for (const [name0, payload] of Object.entries(lib)){
            const baseName = String(name0);
            const name = uniqueName(existingNames, baseName);
            existingNames.add(name);

            const text = String(payload?.text ?? "");
            const updatedAt = String(payload?.updatedAt ?? nowISO());
            const createdAt = String(payload?.createdAt ?? updatedAt);

            newScenes.push({
              id: uuid(),
              name,
              text,
              createdAt,
              updatedAt
            });
            imported++;
          }
        } catch {}
      }

      if (imported > 0){
        db.scenes = newScenes;
        writeSceneDB(db);

        // migrate selection by name (best-effort)
        let oldSelectedName = "";
        for (const k of OLD_SELECTED_NAME_KEYS){
          const v = localStorage.getItem(k);
          if (v) { oldSelectedName = v; break; }
        }
        if (oldSelectedName){
          const hit = db.scenes.find(s => s.name === oldSelectedName);
          if (hit) localStorage.setItem(LS_SCENE_SELECTED_ID, hit.id);
        }

        showToast(`旧データを移行しました（${imported}件）`);
      }

      localStorage.setItem(LS_SCENE_MIGRATED, "1");
    }

    function sceneHasDirtyDraft(db, id){
      const s = findSceneById(db, id);
      if (!s) return false;
      const saved = s.text ?? "";
      const draft = getSceneDraftRaw(id);
      return draft !== null && draft !== saved;
    }

    function sortedFilteredScenes(db, q){
      const query = (q ?? "").trim().toLowerCase();
      let list = db.scenes.slice();
      if (query){
        list = list.filter(s => (s.name ?? "").toLowerCase().includes(query));
      }
      list.sort((a,b)=>{
        const ua = a.updatedAt ?? "";
        const ub = b.updatedAt ?? "";
        if (ua !== ub) return ua < ub ? 1 : -1;
        return (a.name ?? "").localeCompare((b.name ?? ""), "ja");
      });
      return list;
    }

    let renderScheduled = false;
    function scheduleRenderSceneList(){
      if (renderScheduled) return;
      renderScheduled = true;
      requestAnimationFrame(() => {
        renderScheduled = false;
        renderSceneList();
      });
    }

    function renderSceneList(){
      const db = readSceneDB();
      const items = sortedFilteredScenes(db, search.value);

      sceneList.innerHTML = "";

      for (const s of items){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "sceneItem" + ((s.id === currentSceneId) ? " active" : "");
        btn.dataset.id = s.id;

        const left = document.createElement("div");
        const title = document.createElement("div");
        title.className = "sceneName";
        title.textContent = s.name ?? "(no name)";

        const meta = document.createElement("div");
        meta.className = "sceneMeta";
        meta.textContent = "更新: " + formatUpdated(s.updatedAt);

        left.appendChild(title);
        left.appendChild(meta);

        const dot = document.createElement("div");
        dot.className = "dot" + (sceneHasDirtyDraft(db, s.id) ? " draft" : "");
        dot.title = sceneHasDirtyDraft(db, s.id) ? "未保存の下書きあり" : "";

        btn.appendChild(left);
        btn.appendChild(dot);

        btn.addEventListener("click", () => selectSceneById(s.id));
        sceneList.appendChild(btn);
      }

      sceneCount.textContent = `${db.scenes.length}件`;
      deleteSceneBtn.disabled = (currentSceneId === null);
    }

    function bindSceneEditorTo(id){
      boundSceneId = id;
      scene.dataset.boundSceneId = (id ?? "");
    }

    function loadSceneText(db, id){
      if (id === null){
        const draft = getSceneDraftRaw(null);
        return (draft !== null) ? draft : "";
      }
      const draft = getSceneDraftRaw(id);
      if (draft !== null) return draft;
      const s = findSceneById(db, id);
      return s ? (s.text ?? "") : "";
    }

    function updateSceneUI(){
      const db = readSceneDB();
      const saveBtn = $("sceneSave");
      const saveAsBtn = $("sceneSaveAs");

      if (currentSceneId === null){
        currentSceneNameBadge.textContent = "新規";
        const hasText = (scene.value ?? "").length > 0;
        sceneDirtyBadge.style.display = hasText ? "inline-flex" : "none";
        $("sceneRevert").style.display = "none";
        deleteSceneBtn.disabled = true;

        // ラベル
        saveBtn.textContent = "保存";
        saveAsBtn.textContent = "名前を付けて保存";
        return;
      }

      const s = findSceneById(db, currentSceneId);
      currentSceneNameBadge.textContent = s?.name ?? "（不明）";

      const saved = s?.text ?? "";
      const dirty = (scene.value ?? "") !== saved;

      sceneDirtyBadge.style.display = dirty ? "inline-flex" : "none";
      $("sceneRevert").style.display = dirty ? "inline-flex" : "none";
      deleteSceneBtn.disabled = false;

      // ラベル：編集していたら「更新」
      saveBtn.textContent = dirty ? "更新" : "保存";
      // 既存を開いているなら「複製して保存」
      saveAsBtn.textContent = "複製して保存";
    }

    function commitSceneDraftForBound(){
      const id = boundSceneId;
      setSceneDraft(id, scene.value ?? "");
    }

    function selectSceneById(id){
      if (switchingScene) return;

      commitSceneDraftForBound();

      switchingScene = true;
      switchingFromSceneId = boundSceneId;

      const db = readSceneDB();
      currentSceneId = id;
      localStorage.setItem(LS_SCENE_SELECTED_ID, id);

      scene.value = loadSceneText(db, id);

      requestAnimationFrame(() => {
        bindSceneEditorTo(id);
        switchingScene = false;
        switchingFromSceneId = null;
        updateSceneUI();
        scheduleRenderSceneList();
        showToast("シーンを呼び出しました");
      });
    }

    function newScene(){
      if (switchingScene) return;

      commitSceneDraftForBound();

      switchingScene = true;
      switchingFromSceneId = boundSceneId;

      currentSceneId = null;
      localStorage.setItem(LS_SCENE_SELECTED_ID, "");

      const db = readSceneDB();
      scene.value = loadSceneText(db, null);

      requestAnimationFrame(() => {
        bindSceneEditorTo(null);
        switchingScene = false;
        switchingFromSceneId = null;
        updateSceneUI();
        scheduleRenderSceneList();
        showToast("新規シーン");
      });
    }

    function saveScene(){
      if (switchingScene) { showToast("切替中のため少し待ってください"); return; }

      const db = readSceneDB();

      // 新規は「保存」= 名前を聞いて保存
      if (currentSceneId === null){
        saveSceneAs(); // 名前を付けて保存
        return;
      }

      const s = findSceneById(db, currentSceneId);
      if (!s){ showToast("保存対象が見つかりません"); return; }

      const nextText = scene.value ?? "";
      const prevText = s.text ?? "";

      // ★変更がないなら更新日時を変えない（勝手に先頭へ行かない）
      if (nextText === prevText){
        clearSceneDraft(currentSceneId);
        updateSceneUI();
        scheduleRenderSceneList();
        showToast("変更なし");
        return;
      }

      // ✅ IDで特定した1件だけ更新
      s.text = nextText;
      s.updatedAt = nowISO();

      writeSceneDB(db);
      clearSceneDraft(currentSceneId);

      updateSceneUI();
      scheduleRenderSceneList();
      showToast("更新しました");
    }

    function saveSceneAs(){
      if (switchingScene) { showToast("切替中のため少し待ってください"); return; }

      const db = readSceneDB();
      const existingNames = new Set(db.scenes.map(s => s.name));

      const suggestion =
        (currentSceneId !== null)
          ? (findSceneById(db, currentSceneId)?.name ?? "")
          : "";

      const name0 = (prompt("保存名を入力してください（シーン）", suggestion) ?? "").trim();
      if (!name0){ showToast("キャンセル"); return; }

      // ★同名なら必ず連番で“新規”を作る（上書きしない）
      const finalName = uniqueName(existingNames, name0);

      const id = uuid();
      db.scenes.push({
        id,
        name: finalName,
        text: scene.value ?? "",
        createdAt: nowISO(),
        updatedAt: nowISO()
      });

      writeSceneDB(db);
      clearSceneDraft(null);

      currentSceneId = id;
      localStorage.setItem(LS_SCENE_SELECTED_ID, id);
      bindSceneEditorTo(id);

      updateSceneUI();
      scheduleRenderSceneList();

      if (finalName !== name0) showToast(`「${finalName}」として複製しました`);
      else showToast("名前を付けて保存しました");
    }

    function revertScene(){
      const db = readSceneDB();
      if (currentSceneId === null) return;
      const s = findSceneById(db, currentSceneId);
      if (!s) return;

      scene.value = s.text ?? "";
      clearSceneDraft(currentSceneId);
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("保存済みに戻しました");
    }

    function deleteScene(){
      const db = readSceneDB();
      if (currentSceneId === null) return;
      const s = findSceneById(db, currentSceneId);
      if (!s) return;

      const ok = confirm(`「${s.name}」を削除しますか？（元に戻せません）`);
      if (!ok) return;

      db.scenes = db.scenes.filter(x => x.id !== currentSceneId);
      writeSceneDB(db);
      clearSceneDraft(currentSceneId);

      currentSceneId = null;
      localStorage.setItem(LS_SCENE_SELECTED_ID, "");
      bindSceneEditorTo(null);

      scene.value = loadSceneText(db, null);
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("削除しました");
    }

    // Input -> draft (with switching guard)
    scene.addEventListener("input", () => {
      const targetId = switchingScene ? switchingFromSceneId : boundSceneId;
      setSceneDraft(targetId, scene.value ?? "");
      updateSceneUI();
      scheduleRenderSceneList();
    });

    // =========================
    // Fixed Presets (name based)
    // =========================
    function readFixedLib(){
      try{
        const raw = localStorage.getItem(LS_FIXED_LIB);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === "object") ? obj : {};
      } catch { return {}; }
    }
    function writeFixedLib(lib){
      localStorage.setItem(LS_FIXED_LIB, JSON.stringify(lib));
    }
    function fixedDraftKey(name){
      return LS_FIXED_DRAFT_PREFIX + encodeURIComponent(name);
    }
    function getFixedDraftRaw(name){
      return localStorage.getItem(fixedDraftKey(name));
    }
    function setFixedDraft(name, text){
      localStorage.setItem(fixedDraftKey(name), text ?? "");
    }
    function clearFixedDraft(name){
      localStorage.removeItem(fixedDraftKey(name));
    }
    function sortedFixedNames(lib){
      return Object.keys(lib).sort((a,b)=>{
        const ua = lib[a]?.updatedAt ?? "";
        const ub = lib[b]?.updatedAt ?? "";
        if (ua !== ub) return ua < ub ? 1 : -1;
        return a.localeCompare(b, "ja");
      });
    }
    function ensureFixedDefault(){
      const lib = readFixedLib();
      if (Object.keys(lib).length > 0) return;

      const old = localStorage.getItem(LS_OLD_FIXED_SINGLE) ?? "";
      lib["デフォルト"] = { text: old, updatedAt: nowISO() };
      writeFixedLib(lib);
      localStorage.setItem(LS_FIXED_SELECTED, "デフォルト");
    }
    function renderFixedSelect(){
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);

      fixedSelect.innerHTML = "";
      for (const n of names){
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        fixedSelect.appendChild(opt);
      }

      if (!names.includes(currentFixedName)){
        currentFixedName = names[0] || "デフォルト";
      }
      fixedSelect.value = currentFixedName;
      updateFixedUI();
    }
    function bindFixedEditorTo(name){
      boundFixedName = name;
      fixed.dataset.boundFixedName = name;
    }
    function loadFixedText(name){
      const lib = readFixedLib();
      const draft = getFixedDraftRaw(name);
      if (draft !== null) return draft;
      return String(lib[name]?.text ?? "");
    }
    function updateFixedUI(){
      const lib = readFixedLib();
      const saved = String(lib[currentFixedName]?.text ?? "");
      const dirty = (fixed.value ?? "") !== saved;

      fixedCurrentNameBadge.textContent = currentFixedName || "—";
      fixedDirtyBadge.style.display = dirty ? "inline-flex" : "none";
      $("fixedRevert").style.display = dirty ? "inline-flex" : "none";

      // ラベル：編集していたら「更新」
      $("fixedSave").textContent = dirty ? "更新" : "保存";
      // 固定は常に既存プリセットなので、常に「複製して保存」
      $("fixedSaveAs").textContent = "複製して保存";

      const count = Object.keys(lib).length;
      fixedDeleteBtn.disabled = (count <= 1);
    }
    function commitFixedDraftForBound(){
      if (!boundFixedName) return;
      setFixedDraft(boundFixedName, fixed.value ?? "");
    }
    function selectFixed(name){
      if (!name || switchingFixed) return;

      commitFixedDraftForBound();
      switchingFixed = true;
      switchingFromFixedName = boundFixedName;

      currentFixedName = name;
      localStorage.setItem(LS_FIXED_SELECTED, name);

      fixed.value = loadFixedText(name);

      requestAnimationFrame(() => {
        bindFixedEditorTo(name);
        switchingFixed = false;
        switchingFromFixedName = "";
        renderFixedSelect();
        showToast("固定プリセットを切替");
      });
    }
    function saveFixed(){
      const lib = readFixedLib();
      const prev = String(lib[currentFixedName]?.text ?? "");
      const next = fixed.value ?? "";

      // ★変更がないなら更新日時を変えない
      if (next === prev){
        clearFixedDraft(currentFixedName);
        updateFixedUI();
        showToast("変更なし");
        return;
      }

      lib[currentFixedName] = { text: next, updatedAt: nowISO() };
      writeFixedLib(lib);
      clearFixedDraft(currentFixedName);
      updateFixedUI();
      renderFixedSelect();
      showToast("更新しました");
    }
    function saveFixedAs(){
      const lib = readFixedLib();
      const suggestion = currentFixedName || "";

      const name0 = (prompt("保存名を入力してください（固定）", suggestion) ?? "").trim();
      if (!name0){ showToast("キャンセル"); return; }

      const existingNames = new Set(Object.keys(lib));
      const finalName = uniqueName(existingNames, name0); // ★同名なら（2）（3）…

      lib[finalName] = { text: fixed.value ?? "", updatedAt: nowISO() };
      writeFixedLib(lib);

      currentFixedName = finalName;
      localStorage.setItem(LS_FIXED_SELECTED, finalName);
      clearFixedDraft(finalName);

      renderFixedSelect();
      updateFixedUI();

      if (finalName !== name0) showToast(`「${finalName}」として複製しました`);
      else showToast("複製して保存しました");
    }
    function revertFixed(){
      const lib = readFixedLib();
      fixed.value = String(lib[currentFixedName]?.text ?? "");
      clearFixedDraft(currentFixedName);
      updateFixedUI();
      showToast("保存済みに戻しました");
    }
    function deleteFixed(){
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);
      if (names.length <= 1){ showToast("最後の1件は削除できません"); return; }

      const ok = confirm(`「${currentFixedName}」を削除しますか？（元に戻せません）`);
      if (!ok) return;

      delete lib[currentFixedName];
      writeFixedLib(lib);
      clearFixedDraft(currentFixedName);

      const next = sortedFixedNames(lib)[0];
      currentFixedName = next;
      localStorage.setItem(LS_FIXED_SELECTED, next);
      fixed.value = loadFixedText(next);
      bindFixedEditorTo(next);

      renderFixedSelect();
      updateFixedUI();
      showToast("固定プリセットを削除しました");
    }

    fixed.addEventListener("input", () => {
      const target = switchingFixed ? switchingFromFixedName : boundFixedName;
      if (!target) return;
      setFixedDraft(target, fixed.value ?? "");
      updateFixedUI();
    });

    // =========================
    // Output actions
    // =========================
    function refreshOutput(){
      lastMerged = merge();
      output.value = lastMerged;
    }

    async function doMergeCopy(){
      refreshOutput();
      if (!lastMerged){ showToast("空です"); return; }
      const ok = await copyToClipboard(lastMerged);
      showToast(ok ? "合体してコピーしました" : "コピー失敗：出力欄を使用してください");
      if (!ok) outputDetails.open = true;
    }

    // =========================
    // Export / Import
    // =========================
    $("exportJson").addEventListener("click", () => {
      const data = {
        version: 3,
        exportedAt: nowISO(),
        scenesDB: readSceneDB(),
        fixedPresets: readFixedLib()
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `prompt_tool_backup_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast("エクスポートしました");
    });

    $("importJson").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try{
        const text = await file.text();
        const obj = JSON.parse(text);

        // scenes
        if (obj?.scenesDB?.scenes && Array.isArray(obj.scenesDB.scenes)){
          const db = readSceneDB();
          const existingIds = new Set(db.scenes.map(s=>s.id));
          const existingNames = new Set(db.scenes.map(s=>s.name));

          for (const s of obj.scenesDB.scenes){
            const name0 = String(s?.name ?? "scene");
            const id0 = String(s?.id ?? "");
            const id = (id0 && !existingIds.has(id0)) ? id0 : uuid();
            const name = existingNames.has(name0) ? uniqueName(existingNames, name0) : name0;

            existingIds.add(id);
            existingNames.add(name);

            db.scenes.push({
              id,
              name,
              text: String(s?.text ?? ""),
              createdAt: String(s?.createdAt ?? nowISO()),
              updatedAt: String(s?.updatedAt ?? nowISO())
            });
          }
          writeSceneDB(db);
        } else if (obj?.scenes && typeof obj.scenes === "object"){
          // old style: { name: {text, updatedAt} }
          const db = readSceneDB();
          const existingNames = new Set(db.scenes.map(s=>s.name));
          for (const [name0, payload] of Object.entries(obj.scenes)){
            const name = uniqueName(existingNames, String(name0));
            existingNames.add(name);
            db.scenes.push({
              id: uuid(),
              name,
              text: String(payload?.text ?? ""),
              createdAt: String(payload?.createdAt ?? payload?.updatedAt ?? nowISO()),
              updatedAt: String(payload?.updatedAt ?? nowISO())
            });
          }
          writeSceneDB(db);
        }

        // fixed
        if (obj?.fixedPresets && typeof obj.fixedPresets === "object"){
          const lib = readFixedLib();
          for (const [name, payload] of Object.entries(obj.fixedPresets)){
            // インポート時は同名衝突を連番で回避
            const existingNames = new Set(Object.keys(lib));
            const finalName = existingNames.has(name) ? uniqueName(existingNames, name) : name;
            lib[finalName] = { text: String(payload?.text ?? ""), updatedAt: payload?.updatedAt ?? nowISO() };
          }
          writeFixedLib(lib);
        }

        init();
        showToast("インポートしました");
      } catch {
        showToast("インポート失敗（JSON形式を確認）");
      } finally {
        e.target.value = "";
      }
    });

    // =========================
    // Wiring
    // =========================
    $("mergeCopy").addEventListener("click", doMergeCopy);
    $("mergeCopy2").addEventListener("click", doMergeCopy);

    $("copyOnly").addEventListener("click", async () => {
      if (!output.value) refreshOutput();
      if (!output.value){ showToast("空です"); return; }
      const ok = await copyToClipboard(output.value);
      showToast(ok ? "コピーしました" : "コピーに失敗しました");
    });

    $("showOutput").addEventListener("click", () => {
      refreshOutput();
      outputDetails.open = true;
      output.focus();
    });

    $("refreshOutput").addEventListener("click", () => {
      refreshOutput();
      showToast("更新しました");
    });

    $("copyOutput").addEventListener("click", async () => {
      if (!output.value) refreshOutput();
      if (!output.value){ showToast("空です"); return; }
      outputDetails.open = true;
      output.focus();
      output.select();
      const ok = await copyToClipboard(output.value);
      showToast(ok ? "コピーしました" : "コピーに失敗しました");
    });

    $("newScene").addEventListener("click", newScene);
    $("deleteScene").addEventListener("click", deleteScene);
    $("sceneSave").addEventListener("click", saveScene);
    $("sceneSaveAs").addEventListener("click", saveSceneAs);
    $("sceneRevert").addEventListener("click", revertScene);
    $("sceneClear").addEventListener("click", () => {
      scene.value = "";
      setSceneDraft(boundSceneId, "");
      updateSceneUI();
      scheduleRenderSceneList();
      showToast("シーン入力をクリア");
    });

    search.addEventListener("input", scheduleRenderSceneList);

    fixedSelect.addEventListener("change", () => selectFixed(fixedSelect.value));
    $("openFixed").addEventListener("click", () => { fixedDetails.open = true; fixed.focus(); });

    $("fixedSave").addEventListener("click", saveFixed);
    $("fixedSaveAs").addEventListener("click", saveFixedAs);
    $("fixedRevert").addEventListener("click", revertFixed);
    $("fixedClear").addEventListener("click", () => {
      fixed.value = "";
      setFixedDraft(currentFixedName, "");
      updateFixedUI();
      showToast("固定入力をクリア");
    });
    $("fixedDelete").addEventListener("click", deleteFixed);

    dividerPreset.addEventListener("change", () => {
      dividerCustom.style.display = dividerPreset.value === "CUSTOM" ? "block" : "none";
    });

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "Enter"){
        e.preventDefault();
        doMergeCopy();
        return;
      }
      if (e.ctrlKey && (e.key === "s" || e.key === "S")){
        e.preventDefault();
        const inFixed = (document.activeElement === fixed);
        if (e.shiftKey){
          if (inFixed) saveFixedAs();
          else saveSceneAs();
        } else {
          if (inFixed) saveFixed();
          else saveScene();
        }
      }
    });

    // =========================
    // Init
    // =========================
    function init(){
      // defaults
      dividerPreset.value = "\n\n";
      dividerCustom.value = "";
      dividerCustom.style.display = "none";
      trim.checked = true;

      // migrate old scenes (once)
      migrateOldScenesIfNeeded();

      // load scene selection
      const db = readSceneDB();
      const sel = localStorage.getItem(LS_SCENE_SELECTED_ID) ?? "";
      if (sel && findSceneById(db, sel)){
        currentSceneId = sel;
      } else {
        currentSceneId = null;
      }

      // bind editor and load text
      scene.value = loadSceneText(db, currentSceneId);
      bindSceneEditorTo(currentSceneId);

      updateSceneUI();
      renderSceneList();

      // fixed
      ensureFixedDefault();
      const lib = readFixedLib();
      const names = sortedFixedNames(lib);
      currentFixedName = localStorage.getItem(LS_FIXED_SELECTED) ?? names[0];
      if (!lib[currentFixedName]) currentFixedName = names[0];
      localStorage.setItem(LS_FIXED_SELECTED, currentFixedName);

      fixed.value = loadFixedText(currentFixedName);
      bindFixedEditorTo(currentFixedName);
      renderFixedSelect();
      updateFixedUI();

      // output
      refreshOutput();
    }

    init();
  </script>
</body>
</html>
